# Quorlin Compiler Architecture

This document provides a deep dive into the Quorlin compiler's internal architecture.

## Overview

The Quorlin compiler (`qlc`) is a multi-stage compiler written in Rust that transforms Quorlin (`.ql`) source code into native bytecode for multiple blockchain targets.

```
┌─────────────────────────────────────────────────────────────────────────┐
│                           QUORLIN COMPILER (qlc)                        │
├─────────────────────────────────────────────────────────────────────────┤
│                                                                         │
│  ┌─────────────┐    ┌─────────────┐    ┌─────────────┐                 │
│  │   LEXER     │───▶│   PARSER    │───▶│    AST      │                 │
│  │  (tokens)   │    │  (LALRPOP)  │    │ (validated) │                 │
│  └─────────────┘    └─────────────┘    └──────┬──────┘                 │
│                                               │                         │
│                                               ▼                         │
│                                    ┌─────────────────┐                  │
│                                    │   SEMANTIC      │                  │
│                                    │   ANALYSIS      │                  │
│                                    │  (type check)   │                  │
│                                    └────────┬────────┘                  │
│                                             │                           │
│                                             ▼                           │
│                                    ┌─────────────────┐                  │
│                                    │   QUORLIN IR    │                  │
│                                    │  (unified repr) │                  │
│                                    └────────┬────────┘                  │
│                                             │                           │
│              ┌──────────────────────────────┼──────────────────────┐    │
│              │                              │                      │    │
│              ▼                              ▼                      ▼    │
│     ┌─────────────────┐          ┌─────────────────┐    ┌─────────────┐│
│     │   EVM BACKEND   │          │ SOLANA BACKEND  │    │ INK BACKEND ││
│     │                 │          │                 │    │             ││
│     │  ┌───────────┐  │          │  ┌───────────┐  │    │ ┌─────────┐ ││
│     │  │ Yul Gen   │  │          │  │ Rust Gen  │  │    │ │Rust Gen │ ││
│     │  └─────┬─────┘  │          │  └─────┬─────┘  │    │ └────┬────┘ ││
│     │        ▼        │          │        ▼        │    │      ▼      ││
│     │  ┌───────────┐  │          │  ┌───────────┐  │    │ ┌─────────┐ ││
│     │  │ solc/EVM  │  │          │  │cargo-bpf  │  │    │ │cargo-c  │ ││
│     │  │ bytecode  │  │          │  │ compile   │  │    │ │ompile  │ ││
│     │  └───────────┘  │          │  └───────────┘  │    │ └─────────┘ ││
│     └────────┬────────┘          └────────┬────────┘    └──────┬──────┘│
│              │                            │                    │       │
│              ▼                            ▼                    ▼       │
│         .evm/.bin                      .so (BPF)         .wasm + JSON  │
│                                                                        │
└────────────────────────────────────────────────────────────────────────┘
```

## Compiler Phases

### Phase 1: Lexical Analysis (`quorlin-lexer`)

**Purpose:** Transform source text into a stream of tokens.

**Key Components:**
- `token.rs` — Token definitions using the `logos` crate
- `lexer.rs` — Main lexer implementation
- `indent.rs` — Python-style indentation processor

**Key Features:**
- Uses `logos` for efficient token recognition
- Custom indentation processor that inserts `INDENT` and `DEDENT` tokens
- Preserves source locations for error reporting
- Supports all Python keywords plus blockchain-specific additions

**Example:**
```python
contract Token:
    name: str = "QRL"
```

Tokens: `Contract`, `Ident("Token")`, `:`, `Newline`, `INDENT`, `Ident("name")`, `:`, `Str`, `=`, `StringLiteral("QRL")`, `Newline`, `DEDENT`

### Phase 2: Parsing (`quorlin-parser`)

**Purpose:** Build an Abstract Syntax Tree from tokens.

**Key Components:**
- `grammar.lalrpop` — LALRPOP grammar definition (to be implemented)
- `ast.rs` — AST node definitions
- Parser generated by LALRPOP at build time

**AST Structure:**
```rust
Module
├── Import statements
├── Event/Error declarations
└── Contracts
    ├── State variables
    ├── Constructor
    └── Functions
        ├── Parameters
        ├── Return type
        └── Statements
```

### Phase 3: Semantic Analysis (`quorlin-semantics`)

**Purpose:** Validate semantic correctness and type safety.

**Key Tasks:**
1. **Type Checking**
   - Verify type annotations match usage
   - Infer types for local variables
   - Check function signatures match calls

2. **Name Resolution**
   - Resolve identifiers to declarations
   - Check for undefined variables
   - Validate import paths

3. **Storage Layout**
   - Assign storage slots to state variables
   - Compute packing strategies
   - Validate mapping key types

4. **Security Analysis**
   - Detect potential reentrancy
   - Warn about unchecked external calls
   - Flag unsafe patterns

### Phase 4: IR Generation (`quorlin-ir`)

**Purpose:** Lower AST to target-agnostic intermediate representation.

**IR Design:**
- SSA (Static Single Assignment) form
- Platform-independent instructions
- Optimizations applied at IR level

**Example IR:**
```
function transfer(to: address, amount: uint256) -> bool:
  %1 = storage_load balances[msg.sender]
  %2 = ge %1, amount
  require %2, "Insufficient balance"
  %3 = sub %1, amount
  storage_store balances[msg.sender], %3
  %4 = storage_load balances[to]
  %5 = add %4, amount
  storage_store balances[to], %5
  return true
```

### Phase 5: Backend Code Generation

Each backend translates IR to native code for its target platform.

#### EVM Backend (`quorlin-codegen-evm`)

**Output:** Yul intermediate → EVM bytecode

**Process:**
1. Generate Yul code from IR
2. Generate ABI JSON
3. Invoke `solc --yul` to compile to bytecode
4. Package bytecode + ABI

**Storage Mapping:**
- State variables → Sequential storage slots starting at 0
- Mappings → `keccak256(key . slot)`
- Dynamic arrays → Length at slot, data at `keccak256(slot)`

#### Solana Backend (`quorlin-codegen-solana`)

**Output:** Rust/Anchor program → BPF bytecode

**Process:**
1. Generate Rust/Anchor code from IR
2. Create account structures
3. Generate instruction handlers
4. Invoke `cargo build-sbf` to compile

**Storage Mapping:**
- State variables → Struct fields in program account
- Mappings → PDAs (Program Derived Addresses)
- Events → `emit!()` macro calls

#### ink! Backend (`quorlin-codegen-ink`)

**Output:** ink! Rust contract → Wasm bytecode

**Process:**
1. Generate ink! Rust code from IR
2. Add `#[ink(...)]` attributes
3. Generate contract metadata
4. Invoke `cargo contract build`

**Storage Mapping:**
- State variables → `#[ink(storage)]` struct
- Mappings → `ink::storage::Mapping<K, V>`
- Events → `#[ink(event)]` structs

## Crate Organization

```
quorlin/
├── qlc/                    # CLI binary
├── quorlin-lexer/          # Tokenization
├── quorlin-parser/         # Parsing (LALRPOP)
├── quorlin-semantics/      # Type checking, analysis
├── quorlin-ir/             # Intermediate representation
├── quorlin-codegen-evm/    # EVM code generator
├── quorlin-codegen-solana/ # Solana code generator
├── quorlin-codegen-ink/    # ink! code generator
└── quorlin-common/         # Shared utilities
```

## Key Design Decisions

### Why Rust?

1. **Memory safety** without garbage collection
2. **LLVM integration** for multi-target compilation
3. **Rich ecosystem** for parsing (LALRPOP, logos)
4. **Native compatibility** with Solana and ink! toolchains
5. **Performance** suitable for large contract compilation

### Why LALRPOP?

1. **Declarative grammar** definition
2. **Excellent error messages**
3. **Type-safe** parser generation
4. **Good indentation support** with custom lexer

### Why Separate IR?

1. **Target independence** — Optimizations apply to all backends
2. **Maintainability** — Add new targets without changing frontends
3. **Testing** — Verify correctness at IR level
4. **Debugging** — Inspect intermediate state

## Error Handling

All errors use the `miette` crate for beautiful diagnostics:

```
error: type mismatch
  --> token.ql:42:21
   |
42 |     balance = "not a number"
   |               ^^^^^^^^^^^^^^ expected `uint256`, found `str`
   |
   help: try converting the string to a number with `uint256(...)`
```

## Testing Strategy

1. **Unit Tests** — Each module >80% coverage
2. **Integration Tests** — Full compilation pipeline
3. **Golden Tests** — Snapshot testing with `insta`
4. **Property Tests** — Fuzz testing with `proptest`
5. **E2E Tests** — Deploy to local testnets

## Future Optimizations

1. **Incremental Compilation** — Cache IR between builds
2. **Link-Time Optimization** — Cross-contract optimization
3. **Gas Optimization** — Backend-specific gas reduction
4. **Parallel Compilation** — Multi-threaded compilation

## Contributing

To add a new backend:

1. Create `quorlin-codegen-PLATFORM` crate
2. Implement `CodeGenerator` trait
3. Map IR instructions to platform primitives
4. Add integration tests
5. Update CLI to support new `--target`

See `CONTRIBUTING.md` for detailed guidelines.
