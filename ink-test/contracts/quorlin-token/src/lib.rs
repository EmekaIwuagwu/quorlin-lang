// Generated by Quorlin compiler
// Target: Polkadot/ink!

#![cfg_attr(not(feature = "std"), no_std, no_main)]

#[ink::contract]
mod token {
    use ink::storage::Mapping;
    use ink::prelude::string::String;

    #[ink(storage)]
    pub struct Token {
        total_supply: u128,
        balances: Mapping<AccountId, u128>,
        symbol: String,
        decimals: u8,
        allowances: Mapping<(AccountId, AccountId), u128>,
        name: String,
    }

    #[ink(event)]
    pub struct Transfer {
        #[ink(topic)]
        pub from_addr: AccountId,
        pub to_addr: AccountId,
        pub value: u128,
    }

    #[ink(event)]
    pub struct Approval {
        #[ink(topic)]
        pub owner: AccountId,
        pub spender: AccountId,
        pub value: u128,
    }

    impl Token {
        #[ink(constructor)]
        pub fn new(initial_supply: u128) -> Self {
            let mut instance = Self {
                total_supply: Default::default(),
                balances: Default::default(),
                symbol: Default::default(),
                decimals: Default::default(),
                allowances: Default::default(),
                name: Default::default(),
            };

            instance.total_supply = initial_supply;
            instance.balances.insert(Self::env().caller(), &initial_supply);
            Self::env().emit_event(Transfer {
                from_addr: AccountId::from([0u8; 32]),
                to_addr: Self::env().caller(),
                value: initial_supply,
            });
            instance
        }

        #[ink(message)]
        pub fn transfer(&mut self, to: AccountId, amount: u128) -> bool {
            assert!((self.balances.get(Self::env().caller()).unwrap_or_default() >= amount), "Insufficient balance");
            assert!((to != AccountId::from([0u8; 32])), "Cannot send to zero address");
            self.balances.insert(Self::env().caller(), &self.balances.get(Self::env().caller()).unwrap_or_default().checked_sub(amount).expect("arithmetic underflow"));
            self.balances.insert(to, &self.balances.get(to).unwrap_or_default().checked_add(amount).expect("arithmetic overflow"));
            Self::env().emit_event(Transfer {
                from_addr: Self::env().caller(),
                to_addr: to,
                value: amount,
            });
            return true;
        }

        #[ink(message)]
        pub fn approve(&mut self, spender: AccountId, amount: u128) -> bool {
            assert!((spender != AccountId::from([0u8; 32])), "Cannot approve zero address");
            self.allowances.insert((Self::env().caller(), spender), &amount);
            Self::env().emit_event(Approval {
                owner: Self::env().caller(),
                spender: spender,
                value: amount,
            });
            return true;
        }

        #[ink(message)]
        pub fn transfer_from(&mut self, from_addr: AccountId, to: AccountId, amount: u128) -> bool {
            assert!((self.balances.get(from_addr).unwrap_or_default() >= amount), "Insufficient balance");
            assert!((self.allowances.get((from_addr, Self::env().caller())).unwrap_or_default() >= amount), "Insufficient allowance");
            assert!((to != AccountId::from([0u8; 32])), "Cannot send to zero address");
            self.balances.insert(from_addr, &self.balances.get(from_addr).unwrap_or_default().checked_sub(amount).expect("arithmetic underflow"));
            self.balances.insert(to, &self.balances.get(to).unwrap_or_default().checked_add(amount).expect("arithmetic overflow"));
            self.allowances.insert((from_addr, Self::env().caller()), &self.allowances.get((from_addr, Self::env().caller())).unwrap_or_default().checked_sub(amount).expect("arithmetic underflow"));
            Self::env().emit_event(Transfer {
                from_addr: from_addr,
                to_addr: to,
                value: amount,
            });
            return true;
        }

        #[ink(message)]
        pub fn balance_of(&self, owner: AccountId) -> u128 {
            return self.balances.get(owner).unwrap_or_default();
        }

        #[ink(message)]
        pub fn allowance(&self, owner: AccountId, spender: AccountId) -> u128 {
            return self.allowances.get((owner, spender)).unwrap_or_default();
        }

        #[ink(message)]
        pub fn get_total_supply(&self) -> u128 {
            return self.total_supply;
        }

    }
}
