// Generated by Quorlin compiler
// Target: Solana/Anchor

use anchor_lang::prelude::*;
use std::collections::HashMap;

declare_id!("Fg6PaFpoGXkYsidMpWTK6W2BeZ7FEfcYkg476zPFsLnS");

#[program]
pub mod token {
    use super::*;

    pub fn initialize(
        ctx: Context<Initialize>,
        initial_supply: u128,
    ) -> Result<()> {
        let contract = &mut ctx.accounts.contract;
        let signer = ctx.accounts.signer.key();

        contract.total_supply = initial_supply;
        contract.balances.insert(signer, initial_supply);
        emit!(TransferEvent {
            from_addr: Pubkey::default(),
            to_addr: signer,
            value: initial_supply,
        });
        Ok(())
    }

    pub fn transfer(
        ctx: Context<Transfer>,
        to: Pubkey,
        amount: u128,
    ) -> Result<bool> {
        let contract = &mut ctx.accounts.contract;
        let signer = ctx.accounts.signer.key();

        let sender_balance = contract.balances.get(&signer).cloned().unwrap_or_default();
        require!(sender_balance >= amount, ErrorCode::InsufficientBalance);
        require!(to != Pubkey::default(), ErrorCode::ZeroAddress);

        let new_sender_balance = sender_balance.checked_sub(amount).expect("arithmetic underflow");
        let to_balance = contract.balances.get(&to).cloned().unwrap_or_default();
        let new_to_balance = to_balance.checked_add(amount).expect("arithmetic overflow");

        contract.balances.insert(signer, new_sender_balance);
        contract.balances.insert(to, new_to_balance);
        emit!(TransferEvent {
            from_addr: signer,
            to_addr: to,
            value: amount,
        });
        return Ok(true);
    }

    pub fn approve(
        ctx: Context<Approve>,
        spender: Pubkey,
        amount: u128,
    ) -> Result<bool> {
        let contract = &mut ctx.accounts.contract;
        let signer = ctx.accounts.signer.key();

        require!((spender != Pubkey::default()), ErrorCode::ZeroApproval);
        contract.allowances.entry(signer).or_insert_with(HashMap::new).insert(spender, amount);
        emit!(ApprovalEvent {
            owner: signer,
            spender: spender,
            value: amount,
        });
        return Ok(true);
    }

    pub fn transfer_from(
        ctx: Context<TransferFrom>,
        from_addr: Pubkey,
        to: Pubkey,
        amount: u128,
    ) -> Result<bool> {
        let contract = &mut ctx.accounts.contract;
        let signer = ctx.accounts.signer.key();

        let from_balance = contract.balances.get(&from_addr).cloned().unwrap_or_default();
        let current_allowance = contract.allowances.get(&from_addr).and_then(|inner| inner.get(&signer)).cloned().unwrap_or_default();

        require!(from_balance >= amount, ErrorCode::InsufficientBalance);
        require!(current_allowance >= amount, ErrorCode::InsufficientAllowance);
        require!(to != Pubkey::default(), ErrorCode::ZeroAddress);

        let new_from_balance = from_balance.checked_sub(amount).expect("arithmetic underflow");
        let to_balance = contract.balances.get(&to).cloned().unwrap_or_default();
        let new_to_balance = to_balance.checked_add(amount).expect("arithmetic overflow");
        let new_allowance = current_allowance - amount;

        contract.balances.insert(from_addr, new_from_balance);
        contract.balances.insert(to, new_to_balance);
        contract.allowances.entry(from_addr).or_insert_with(HashMap::new).insert(signer, new_allowance);
        emit!(TransferEvent {
            from_addr: from_addr,
            to_addr: to,
            value: amount,
        });
        return Ok(true);
    }

    pub fn balance_of(
        ctx: Context<BalanceOf>,
        owner: Pubkey,
    ) -> Result<u128> {
        let contract = &mut ctx.accounts.contract;
        let signer = ctx.accounts.signer.key();

        return Ok(contract.balances.get(&owner).cloned().unwrap_or_default());
    }

    pub fn allowance(
        ctx: Context<Allowance>,
        owner: Pubkey,
        spender: Pubkey,
    ) -> Result<u128> {
        let contract = &mut ctx.accounts.contract;
        let signer = ctx.accounts.signer.key();

        return Ok(contract.allowances.get(&owner).and_then(|inner| inner.get(&spender)).cloned().unwrap_or_default());
    }

    pub fn get_total_supply(
        ctx: Context<GetTotalSupply>,
    ) -> Result<u128> {
        let contract = &mut ctx.accounts.contract;
        let signer = ctx.accounts.signer.key();

        return Ok(contract.total_supply);
    }

}

#[derive(Accounts)]
pub struct Initialize<'info> {
    #[account(
        init,
        payer = signer,
        space = 8 + 1024 // Discriminator + data
    )]
    pub contract: Account<'info, ContractState>,
    #[account(mut)]
    pub signer: Signer<'info>,
    pub system_program: Program<'info, System>,
}

#[derive(Accounts)]
pub struct Transfer<'info> {
    #[account(mut)]
    pub contract: Account<'info, ContractState>,
    pub signer: Signer<'info>,
}

#[derive(Accounts)]
pub struct Approve<'info> {
    #[account(mut)]
    pub contract: Account<'info, ContractState>,
    pub signer: Signer<'info>,
}

#[derive(Accounts)]
pub struct TransferFrom<'info> {
    #[account(mut)]
    pub contract: Account<'info, ContractState>,
    pub signer: Signer<'info>,
}

#[derive(Accounts)]
pub struct BalanceOf<'info> {
    pub contract: Account<'info, ContractState>,
    pub signer: Signer<'info>,
}

#[derive(Accounts)]
pub struct Allowance<'info> {
    pub contract: Account<'info, ContractState>,
    pub signer: Signer<'info>,
}

#[derive(Accounts)]
pub struct GetTotalSupply<'info> {
    pub contract: Account<'info, ContractState>,
    pub signer: Signer<'info>,
}

#[account]
pub struct ContractState {
    pub name: String,
    pub decimals: u8,
    pub total_supply: u128,
    pub allowances: HashMap<Pubkey, HashMap<Pubkey, u128>>,
    pub symbol: String,
    pub balances: HashMap<Pubkey, u128>,
}

#[event]
pub struct TransferEvent {
    pub from_addr: Pubkey,
    pub to_addr: Pubkey,
    pub value: u128,
}

#[event]
pub struct ApprovalEvent {
    pub owner: Pubkey,
    pub spender: Pubkey,
    pub value: u128,
}

#[error_code]
pub enum ErrorCode {
    #[msg("Insufficient balance")]
    InsufficientBalance,
    #[msg("Insufficient allowance")]
    InsufficientAllowance,
    #[msg("Cannot send to zero address")]
    ZeroAddress,
    #[msg("Cannot approve zero address")]
    ZeroApproval,
}
