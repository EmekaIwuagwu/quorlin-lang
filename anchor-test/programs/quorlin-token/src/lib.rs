// Generated by Quorlin compiler
// Target: Solana/Anchor

use anchor_lang::prelude::*;

declare_id!("Fg6PaFpoGXkYsidMpWTK6W2BeZ7FEfcYkg476zPFsLnS");

#[program]
pub mod token {
    use super::*;

    pub fn initialize(
        ctx: Context<Initialize>,
        initial_supply: u128,
    ) -> Result<()> {
        let contract = &mut ctx.accounts.contract;
        let signer = ctx.accounts.signer.key();

        contract.total_supply = initial_supply;
        if let Some(entry) = contract.balances.iter_mut().find(|(k, _)| k == &signer) {
            entry.1 = initial_supply;
        } else {
            contract.balances.push((signer, initial_supply));
        }
        emit!(TransferEvent {
            from_addr: Pubkey::default(),
            to_addr: signer,
            value: initial_supply,
        });
        Ok(())
    }

    pub fn transfer(
        ctx: Context<Transfer>,
        to: Pubkey,
        amount: u128,
    ) -> Result<bool> {
        let contract = &mut ctx.accounts.contract;
        let signer = ctx.accounts.signer.key();

        require!((contract.balances.iter().find(|(k, _)| k == &signer).map(|(_, v)| *v).unwrap_or_default() >= amount), ErrorCode::InsufficientBalance);
        require!((to != Pubkey::default()), ErrorCode::ZeroAddress);
        let temp_value_8 = contract.balances.iter().find(|(k, _)| k == &signer).map(|(_, v)| *v).unwrap_or_default().checked_sub(amount).expect("arithmetic underflow");
        if let Some(entry) = contract.balances.iter_mut().find(|(k, _)| k == &signer) {
            entry.1 = temp_value_8;
        } else {
            contract.balances.push((signer, temp_value_8));
        }
        let temp_value_8 = contract.balances.iter().find(|(k, _)| k == &to).map(|(_, v)| *v).unwrap_or_default().checked_add(amount).expect("arithmetic overflow");
        if let Some(entry) = contract.balances.iter_mut().find(|(k, _)| k == &to) {
            entry.1 = temp_value_8;
        } else {
            contract.balances.push((to, temp_value_8));
        }
        emit!(TransferEvent {
            from_addr: signer,
            to_addr: to,
            value: amount,
        });
        return Ok(true);
    }

    pub fn approve(
        ctx: Context<Approve>,
        spender: Pubkey,
        amount: u128,
    ) -> Result<bool> {
        let contract = &mut ctx.accounts.contract;
        let signer = ctx.accounts.signer.key();

        require!((spender != Pubkey::default()), ErrorCode::ZeroApproval);
        if let Some((_, inner)) = contract.allowances.iter_mut().find(|(k, _)| k == &signer) {
            if let Some(entry) = inner.iter_mut().find(|(k, _)| k == &spender) {
                entry.1 = amount;
            } else {
                inner.push((spender, amount));
            }
        } else {
            contract.allowances.push((signer, vec![(spender, amount)]));
        }
        emit!(ApprovalEvent {
            owner: signer,
            spender: spender,
            value: amount,
        });
        return Ok(true);
    }

    pub fn transfer_from(
        ctx: Context<TransferFrom>,
        from_addr: Pubkey,
        to: Pubkey,
        amount: u128,
    ) -> Result<bool> {
        let contract = &mut ctx.accounts.contract;
        let signer = ctx.accounts.signer.key();

        require!((contract.balances.iter().find(|(k, _)| k == &from_addr).map(|(_, v)| *v).unwrap_or_default() >= amount), ErrorCode::InsufficientBalance);
        require!((contract.allowances.iter().find(|(k, _)| k == &from_addr).and_then(|(_, inner)| inner.iter().find(|(k, _)| k == &signer).map(|(_, v)| *v)).unwrap_or_default() >= amount), ErrorCode::InsufficientAllowance);
        require!((to != Pubkey::default()), ErrorCode::ZeroAddress);
        let temp_value_8 = contract.balances.iter().find(|(k, _)| k == &from_addr).map(|(_, v)| *v).unwrap_or_default().checked_sub(amount).expect("arithmetic underflow");
        if let Some(entry) = contract.balances.iter_mut().find(|(k, _)| k == &from_addr) {
            entry.1 = temp_value_8;
        } else {
            contract.balances.push((from_addr, temp_value_8));
        }
        let temp_value_8 = contract.balances.iter().find(|(k, _)| k == &to).map(|(_, v)| *v).unwrap_or_default().checked_add(amount).expect("arithmetic overflow");
        if let Some(entry) = contract.balances.iter_mut().find(|(k, _)| k == &to) {
            entry.1 = temp_value_8;
        } else {
            contract.balances.push((to, temp_value_8));
        }
        let temp_value_8 = (contract.allowances.iter().find(|(k, _)| k == &from_addr).and_then(|(_, inner)| inner.iter().find(|(k, _)| k == &signer).map(|(_, v)| *v)).unwrap_or_default() - amount);
        if let Some((_, inner)) = contract.allowances.iter_mut().find(|(k, _)| k == &from_addr) {
            if let Some(entry) = inner.iter_mut().find(|(k, _)| k == &signer) {
                entry.1 = temp_value_8;
            } else {
                inner.push((signer, temp_value_8));
            }
        } else {
            contract.allowances.push((from_addr, vec![(signer, temp_value_8)]));
        }
        emit!(TransferEvent {
            from_addr: from_addr,
            to_addr: to,
            value: amount,
        });
        return Ok(true);
    }

    pub fn balance_of(
        ctx: Context<BalanceOf>,
        owner: Pubkey,
    ) -> Result<u128> {
        let contract = &mut ctx.accounts.contract;
        let signer = ctx.accounts.signer.key();

        return Ok(contract.balances.iter().find(|(k, _)| k == &owner).map(|(_, v)| *v).unwrap_or_default());
    }

    pub fn allowance(
        ctx: Context<Allowance>,
        owner: Pubkey,
        spender: Pubkey,
    ) -> Result<u128> {
        let contract = &mut ctx.accounts.contract;
        let signer = ctx.accounts.signer.key();

        return Ok(contract.allowances.iter().find(|(k, _)| k == &owner).and_then(|(_, inner)| inner.iter().find(|(k, _)| k == &spender).map(|(_, v)| *v)).unwrap_or_default());
    }

    pub fn get_total_supply(
        ctx: Context<GetTotalSupply>,
    ) -> Result<u128> {
        let contract = &mut ctx.accounts.contract;
        let signer = ctx.accounts.signer.key();

        return Ok(contract.total_supply);
    }

}

#[derive(Accounts)]
pub struct Initialize<'info> {
    #[account(
        init,
        payer = signer,
        space = 8 + 1024 // Discriminator + data
    )]
    pub contract: Account<'info, ContractState>,
    #[account(mut)]
    pub signer: Signer<'info>,
    pub system_program: Program<'info, System>,
}

#[derive(Accounts)]
pub struct Transfer<'info> {
    #[account(mut)]
    pub contract: Account<'info, ContractState>,
    pub signer: Signer<'info>,
}

#[derive(Accounts)]
pub struct Approve<'info> {
    #[account(mut)]
    pub contract: Account<'info, ContractState>,
    pub signer: Signer<'info>,
}

#[derive(Accounts)]
pub struct TransferFrom<'info> {
    #[account(mut)]
    pub contract: Account<'info, ContractState>,
    pub signer: Signer<'info>,
}

#[derive(Accounts)]
pub struct BalanceOf<'info> {
    pub contract: Account<'info, ContractState>,
    pub signer: Signer<'info>,
}

#[derive(Accounts)]
pub struct Allowance<'info> {
    pub contract: Account<'info, ContractState>,
    pub signer: Signer<'info>,
}

#[derive(Accounts)]
pub struct GetTotalSupply<'info> {
    pub contract: Account<'info, ContractState>,
    pub signer: Signer<'info>,
}

#[account]
pub struct ContractState {
    pub name: String,
    pub symbol: String,
    pub allowances: Vec<(Pubkey, Vec<(Pubkey, u128)>)>,
    pub decimals: u8,
    pub total_supply: u128,
    pub balances: Vec<(Pubkey, u128)>,
}

#[event]
pub struct TransferEvent {
    pub from_addr: Pubkey,
    pub to_addr: Pubkey,
    pub value: u128,
}

#[event]
pub struct ApprovalEvent {
    pub owner: Pubkey,
    pub spender: Pubkey,
    pub value: u128,
}

#[error_code]
pub enum ErrorCode {
    #[msg("Insufficient balance")]
    InsufficientBalance,
    #[msg("Insufficient allowance")]
    InsufficientAllowance,
    #[msg("Cannot send to zero address")]
    ZeroAddress,
    #[msg("Cannot approve zero address")]
    ZeroApproval,
}
