// Generated by Quorlin compiler (with manual fixes for Solana/Anchor compatibility)
// Target: Solana/Anchor

use anchor_lang::prelude::*;
use std::collections::HashMap;

declare_id!("Fg6PaFpoGXkYsidMpWTK6W2BeZ7FEfcYkg476zPFsLnS");

#[program]
pub mod quorlin_token {
    use super::*;

    pub fn initialize(
        ctx: Context<Initialize>,
        initial_supply: u64,  // Using u64 for Solana (u128 not well supported in all contexts)
    ) -> Result<()> {
        let contract = &mut ctx.accounts.contract;
        let signer = ctx.accounts.signer.key();

        contract.total_supply = initial_supply;
        // Store balance directly (using Vec for simplicity in MVP)
        contract.owner = signer;
        contract.owner_balance = initial_supply;

        emit!(TransferEvent {
            from_addr: Pubkey::default(),
            to_addr: signer,
            value: initial_supply,
        });
        Ok(())
    }

    pub fn transfer(
        ctx: Context<TransferInstruction>,
        to: Pubkey,
        amount: u64,
    ) -> Result<()> {
        let contract = &mut ctx.accounts.contract;
        let signer = ctx.accounts.signer.key();

        require!(signer == contract.owner, ErrorCode::Unauthorized);
        require!(contract.owner_balance >= amount, ErrorCode::InsufficientBalance);
        require!(to != Pubkey::default(), ErrorCode::InvalidAddress);

        // Simple transfer (owner to recipient)
        contract.owner_balance = contract.owner_balance
            .checked_sub(amount)
            .ok_or(ErrorCode::Overflow)?;

        emit!(TransferEvent {
            from_addr: signer,
            to_addr: to,
            value: amount,
        });

        Ok(())
    }

    pub fn get_total_supply(ctx: Context<ViewInstruction>) -> Result<u64> {
        Ok(ctx.accounts.contract.total_supply)
    }

    pub fn balance_of(ctx: Context<ViewInstruction>) -> Result<u64> {
        Ok(ctx.accounts.contract.owner_balance)
    }
}

#[derive(Accounts)]
pub struct Initialize<'info> {
    #[account(
        init,
        payer = signer,
        space = 8 + 32 + 8 + 8  // discriminator + pubkey + u64 + u64
    )]
    pub contract: Account<'info, ContractState>,
    #[account(mut)]
    pub signer: Signer<'info>,
    pub system_program: Program<'info, System>,
}

#[derive(Accounts)]
pub struct TransferInstruction<'info> {
    #[account(mut)]
    pub contract: Account<'info, ContractState>,
    pub signer: Signer<'info>,
}

#[derive(Accounts)]
pub struct ViewInstruction<'info> {
    pub contract: Account<'info, ContractState>,
    pub signer: Signer<'info>,
}

#[account]
pub struct ContractState {
    pub owner: Pubkey,
    pub total_supply: u64,
    pub owner_balance: u64,
}

#[event]
pub struct TransferEvent {
    pub from_addr: Pubkey,
    pub to_addr: Pubkey,
    pub value: u64,
}

#[error_code]
pub enum ErrorCode {
    #[msg("Insufficient balance")]
    InsufficientBalance,
    #[msg("Invalid address")]
    InvalidAddress,
    #[msg("Unauthorized")]
    Unauthorized,
    #[msg("Arithmetic overflow")]
    Overflow,
}
