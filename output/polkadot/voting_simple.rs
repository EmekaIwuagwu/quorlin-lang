// Generated by Quorlin compiler
// Target: Polkadot/ink!

#![cfg_attr(not(feature = "std"), no_std, no_main)]

#[ink::contract]
mod simplevoting {
    use ink::storage::Mapping;
    use ink::prelude::string::String;

    #[ink(storage)]
    pub struct SimpleVoting {
        _voting_period: u128,
        _owner: AccountId,
        _proposal_no_votes: Mapping<u128, u128>,
        _proposal_yes_votes: Mapping<u128, u128>,
        _proposal_descriptions: Mapping<u128, String>,
        _has_voted: Mapping<(u128, AccountId), bool>,
        _proposal_count: u128,
        _voter_weights: Mapping<AccountId, u128>,
        _proposal_executed: Mapping<u128, bool>,
    }

    #[ink(event)]
    pub struct ProposalCreated {
        #[ink(topic)]
        pub proposal_id: u128,
        pub description: String,
        pub creator: AccountId,
    }

    #[ink(event)]
    pub struct Voted {
        #[ink(topic)]
        pub proposal_id: u128,
        pub voter: AccountId,
        pub vote: bool,
    }

    #[ink(event)]
    pub struct ProposalExecuted {
        #[ink(topic)]
        pub proposal_id: u128,
    }

    impl SimpleVoting {
        #[ink(constructor)]
        pub fn new(voting_period: u128) -> Self {
            let mut instance = Self {
                _voting_period: Default::default(),
                _owner: Default::default(),
                _proposal_no_votes: Default::default(),
                _proposal_yes_votes: Default::default(),
                _proposal_descriptions: Default::default(),
                _has_voted: Default::default(),
                _proposal_count: Default::default(),
                _voter_weights: Default::default(),
                _proposal_executed: Default::default(),
            };

            instance._owner = Self::env().caller();
            instance._proposal_count = 0;
            instance._voting_period = voting_period;
            instance._voter_weights.insert(Self::env().caller(), &100);
            instance
        }

        #[ink(message)]
        pub fn get_proposal_count(&self) -> u128 {
            return self._proposal_count;
        }

        #[ink(message)]
        pub fn get_proposal_votes(&self, proposal_id: u128) -> (u128, u128) {
            return (self._proposal_yes_votes.get(proposal_id).unwrap_or_default(), self._proposal_no_votes.get(proposal_id).unwrap_or_default());
        }

        #[ink(message)]
        pub fn has_voted(&self, proposal_id: u128, voter: AccountId) -> bool {
            return self._has_voted.get((proposal_id, voter)).unwrap_or_default();
        }

        #[ink(message)]
        pub fn get_voter_weight(&self, voter: AccountId) -> u128 {
            return self._voter_weights.get(voter).unwrap_or_default();
        }

        #[ink(message)]
        pub fn create_proposal(&mut self, description: String) {
            assert!((self._voter_weights.get(Self::env().caller()).unwrap_or_default() > 0), "Insufficient balance");
            let proposal_id = self._proposal_count;
            self._proposal_count = self._proposal_count.checked_add(1).expect("arithmetic overflow");
            self._proposal_descriptions.insert(proposal_id, &description);
            self._proposal_yes_votes.insert(proposal_id, &0);
            self._proposal_no_votes.insert(proposal_id, &0);
            self._proposal_executed.insert(proposal_id, &false);
            Self::env().emit_event(ProposalCreated {
                proposal_id: proposal_id,
                description: description,
                creator: Self::env().caller(),
            });
        }

        #[ink(message)]
        pub fn vote(&mut self, proposal_id: u128, support: bool) {
            assert!((proposal_id < self._proposal_count), "Insufficient balance");
            assert!((self._has_voted.get((proposal_id, Self::env().caller())).unwrap_or_default() == false), "Insufficient allowance");
            assert!((self._voter_weights.get(Self::env().caller()).unwrap_or_default() > 0), "Insufficient balance");
            assert!((self._proposal_executed.get(proposal_id).unwrap_or_default() == false), "Insufficient balance");
            let voter_weight = self._voter_weights.get(Self::env().caller()).unwrap_or_default();
            self._has_voted.insert((proposal_id, Self::env().caller()), &true);
            if support {
                self._proposal_yes_votes.insert(proposal_id, &self._proposal_yes_votes.get(proposal_id).unwrap_or_default().checked_add(voter_weight).expect("arithmetic overflow"));
            } else {
                self._proposal_no_votes.insert(proposal_id, &self._proposal_no_votes.get(proposal_id).unwrap_or_default().checked_add(voter_weight).expect("arithmetic overflow"));
            }
            Self::env().emit_event(Voted {
                proposal_id: proposal_id,
                voter: Self::env().caller(),
                vote: support,
            });
        }

        #[ink(message)]
        pub fn execute_proposal(&mut self, proposal_id: u128) {
            assert!((Self::env().caller() == self._owner), "Insufficient allowance");
            assert!((proposal_id < self._proposal_count), "Insufficient balance");
            assert!((self._proposal_executed.get(proposal_id).unwrap_or_default() == false), "Insufficient balance");
            assert!((self._proposal_yes_votes.get(proposal_id).unwrap_or_default() > self._proposal_no_votes.get(proposal_id).unwrap_or_default()), "Insufficient balance");
            self._proposal_executed.insert(proposal_id, &true);
            Self::env().emit_event(ProposalExecuted {
                proposal_id: proposal_id,
            });
        }

        #[ink(message)]
        pub fn set_voter_weight(&mut self, voter: AccountId, weight: u128) {
            assert!((Self::env().caller() == self._owner), "Insufficient allowance");
            assert!((voter != AccountId::from([0u8; 32])), "Cannot send to zero address");
            self._voter_weights.insert(voter, &weight);
        }

    }
}
