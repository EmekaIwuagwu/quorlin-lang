// Generated by Quorlin compiler
// Target: Polkadot/ink!

#![cfg_attr(not(feature = "std"), no_std, no_main)]

#[ink::contract]
mod simpletoken {
    use ink::storage::Mapping;
    use ink::prelude::string::String;

    #[ink(storage)]
    pub struct SimpleToken {
        _symbol: String,
        _allowances: Mapping<(AccountId, AccountId), u128>,
        _owner: AccountId,
        _decimals: u128,
        _balances: Mapping<AccountId, u128>,
        _name: String,
        _total_supply: u128,
    }

    #[ink(event)]
    pub struct Transfer {
        #[ink(topic)]
        pub from_address: AccountId,
        pub to: AccountId,
        pub amount: u128,
    }

    #[ink(event)]
    pub struct Approval {
        #[ink(topic)]
        pub owner: AccountId,
        pub spender: AccountId,
        pub amount: u128,
    }

    #[ink(event)]
    pub struct Mint {
        #[ink(topic)]
        pub to: AccountId,
        pub amount: u128,
    }

    impl SimpleToken {
        #[ink(constructor)]
        pub fn new(name: String, symbol: String, decimals: u128, initial_supply: u128) -> Self {
            let mut instance = Self {
                _symbol: Default::default(),
                _allowances: Default::default(),
                _owner: Default::default(),
                _decimals: Default::default(),
                _balances: Default::default(),
                _name: Default::default(),
                _total_supply: Default::default(),
            };

            instance._name = name;
            instance._symbol = symbol;
            instance._decimals = decimals;
            instance._owner = Self::env().caller();
            instance._total_supply = initial_supply;
            instance._balances.insert(Self::env().caller(), &initial_supply);
            Self::env().emit_event(Mint {
                to: Self::env().caller(),
                amount: initial_supply,
            });
            Self::env().emit_event(Transfer {
                from_address: AccountId::from([0u8; 32]),
                to: Self::env().caller(),
                amount: initial_supply,
            });
            instance
        }

        #[ink(message)]
        pub fn name(&self) -> String {
            return self._name;
        }

        #[ink(message)]
        pub fn symbol(&self) -> String {
            return self._symbol;
        }

        #[ink(message)]
        pub fn decimals(&self) -> u128 {
            return self._decimals;
        }

        #[ink(message)]
        pub fn total_supply(&self) -> u128 {
            return self._total_supply;
        }

        #[ink(message)]
        pub fn balance_of(&self, account: AccountId) -> u128 {
            return self._balances.get(account).unwrap_or_default();
        }

        #[ink(message)]
        pub fn allowance(&self, owner: AccountId, spender: AccountId) -> u128 {
            return self._allowances.get((owner, spender)).unwrap_or_default();
        }

        #[ink(message)]
        pub fn transfer(&mut self, to: AccountId, amount: u128) {
            assert!((to != AccountId::from([0u8; 32])), "Cannot send to zero address");
            assert!((self._balances.get(Self::env().caller()).unwrap_or_default() >= amount), "Insufficient balance");
            self._balances.insert(Self::env().caller(), &self._balances.get(Self::env().caller()).unwrap_or_default().checked_sub(amount).expect("arithmetic underflow"));
            self._balances.insert(to, &self._balances.get(to).unwrap_or_default().checked_add(amount).expect("arithmetic overflow"));
            Self::env().emit_event(Transfer {
                from_address: Self::env().caller(),
                to: to,
                amount: amount,
            });
        }

        #[ink(message)]
        pub fn approve(&mut self, spender: AccountId, amount: u128) {
            assert!((spender != AccountId::from([0u8; 32])), "Cannot approve zero address");
            self._allowances.insert((Self::env().caller(), spender), &amount);
            Self::env().emit_event(Approval {
                owner: Self::env().caller(),
                spender: spender,
                amount: amount,
            });
        }

        #[ink(message)]
        pub fn transfer_from(&mut self, from_address: AccountId, to: AccountId, amount: u128) {
            assert!((to != AccountId::from([0u8; 32])), "Cannot send to zero address");
            assert!((self._balances.get(from_address).unwrap_or_default() >= amount), "Insufficient balance");
            assert!((self._allowances.get((from_address, Self::env().caller())).unwrap_or_default() >= amount), "Insufficient allowance");
            self._balances.insert(from_address, &self._balances.get(from_address).unwrap_or_default().checked_sub(amount).expect("arithmetic underflow"));
            self._balances.insert(to, &self._balances.get(to).unwrap_or_default().checked_add(amount).expect("arithmetic overflow"));
            self._allowances.insert((from_address, Self::env().caller()), &self._allowances.get((from_address, Self::env().caller())).unwrap_or_default().checked_sub(amount).expect("arithmetic underflow"));
            Self::env().emit_event(Transfer {
                from_address: from_address,
                to: to,
                amount: amount,
            });
        }

        #[ink(message)]
        pub fn mint(&mut self, to: AccountId, amount: u128) {
            assert!((Self::env().caller() == self._owner), "Insufficient allowance");
            assert!((to != AccountId::from([0u8; 32])), "Cannot send to zero address");
            self._total_supply = self._total_supply.checked_add(amount).expect("arithmetic overflow");
            self._balances.insert(to, &self._balances.get(to).unwrap_or_default().checked_add(amount).expect("arithmetic overflow"));
            Self::env().emit_event(Mint {
                to: to,
                amount: amount,
            });
            Self::env().emit_event(Transfer {
                from_address: AccountId::from([0u8; 32]),
                to: to,
                amount: amount,
            });
        }

    }
}
