// Generated by Quorlin compiler
// Target: Solana/Anchor

use anchor_lang::prelude::*;

declare_id!("Fg6PaFpoGXkYsidMpWTK6W2BeZ7FEfcYkg476zPFsLnS");

#[program]
pub mod counter {
    use super::*;

    pub fn initialize(
        ctx: Context<Initialize>,
        initial_count: u128,
    ) -> Result<()> {
        let contract = &mut ctx.accounts.contract;
        let signer = ctx.accounts.signer.key();

        contract._count = initial_count;
        contract._owner = signer;
        Ok(())
    }

    pub fn get_count(
        ctx: Context<GetCount>,
    ) -> Result<u128> {
        let contract = &mut ctx.accounts.contract;
        let signer = ctx.accounts.signer.key();

        return Ok(contract._count);
    }

    pub fn get_owner(
        ctx: Context<GetOwner>,
    ) -> Result<Pubkey> {
        let contract = &mut ctx.accounts.contract;
        let signer = ctx.accounts.signer.key();

        return Ok(contract._owner);
    }

    pub fn increment(
        ctx: Context<Increment>,
    ) -> Result<()> {
        let contract = &mut ctx.accounts.contract;
        let signer = ctx.accounts.signer.key();

        contract._count = (contract._count + 1);
        emit!(IncrementedEvent {
            counter: contract._count,
        });
        Ok(())
    }

    pub fn decrement(
        ctx: Context<Decrement>,
    ) -> Result<()> {
        let contract = &mut ctx.accounts.contract;
        let signer = ctx.accounts.signer.key();

        require!((contract._count > 0), ErrorCode::InsufficientBalance);
        contract._count = (contract._count - 1);
        emit!(DecrementedEvent {
            counter: contract._count,
        });
        Ok(())
    }

    pub fn add(
        ctx: Context<Add>,
        amount: u128,
    ) -> Result<()> {
        let contract = &mut ctx.accounts.contract;
        let signer = ctx.accounts.signer.key();

        require!((signer == contract._owner), ErrorCode::InsufficientAllowance);
        contract._count = (contract._count + amount);
        emit!(IncrementedEvent {
            counter: contract._count,
        });
        Ok(())
    }

    pub fn reset(
        ctx: Context<Reset>,
    ) -> Result<()> {
        let contract = &mut ctx.accounts.contract;
        let signer = ctx.accounts.signer.key();

        require!((signer == contract._owner), ErrorCode::InsufficientAllowance);
        contract._count = 0;
        Ok(())
    }

}

#[derive(Accounts)]
pub struct Initialize<'info> {
    #[account(
        init,
        payer = signer,
        space = 8 + 1024 // Discriminator + data
    )]
    pub contract: Account<'info, ContractState>,
    #[account(mut)]
    pub signer: Signer<'info>,
    pub system_program: Program<'info, System>,
}

#[derive(Accounts)]
pub struct GetCount<'info> {
    pub contract: Account<'info, ContractState>,
    pub signer: Signer<'info>,
}

#[derive(Accounts)]
pub struct GetOwner<'info> {
    pub contract: Account<'info, ContractState>,
    pub signer: Signer<'info>,
}

#[derive(Accounts)]
pub struct Increment<'info> {
    #[account(mut)]
    pub contract: Account<'info, ContractState>,
    pub signer: Signer<'info>,
}

#[derive(Accounts)]
pub struct Decrement<'info> {
    #[account(mut)]
    pub contract: Account<'info, ContractState>,
    pub signer: Signer<'info>,
}

#[derive(Accounts)]
pub struct Add<'info> {
    #[account(mut)]
    pub contract: Account<'info, ContractState>,
    pub signer: Signer<'info>,
}

#[derive(Accounts)]
pub struct Reset<'info> {
    #[account(mut)]
    pub contract: Account<'info, ContractState>,
    pub signer: Signer<'info>,
}

#[account]
pub struct ContractState {
    pub _owner: Pubkey,
    pub _count: u128,
}

#[event]
pub struct IncrementedEvent {
    pub counter: u128,
}

#[event]
pub struct DecrementedEvent {
    pub counter: u128,
}

#[error_code]
pub enum ErrorCode {
    #[msg("Insufficient balance")]
    InsufficientBalance,
    #[msg("Insufficient allowance")]
    InsufficientAllowance,
    #[msg("Cannot send to zero address")]
    ZeroAddress,
    #[msg("Cannot approve zero address")]
    ZeroApproval,
}
