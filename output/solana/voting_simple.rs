// Generated by Quorlin compiler
// Target: Solana/Anchor

use anchor_lang::prelude::*;

declare_id!("Fg6PaFpoGXkYsidMpWTK6W2BeZ7FEfcYkg476zPFsLnS");

#[program]
pub mod simplevoting {
    use super::*;

    pub fn initialize(
        ctx: Context<Initialize>,
        voting_period: u128,
    ) -> Result<()> {
        let contract = &mut ctx.accounts.contract;
        let signer = ctx.accounts.signer.key();

        contract._owner = signer;
        contract._proposal_count = 0;
        contract._voting_period = voting_period;
        if let Some(entry) = contract._voter_weights.iter_mut().find(|(k, _)| k == &signer) {
            entry.1 = 100;
        } else {
            contract._voter_weights.push((signer, 100));
        }
        Ok(())
    }

    pub fn get_proposal_count(
        ctx: Context<GetProposalCount>,
    ) -> Result<u128> {
        let contract = &mut ctx.accounts.contract;
        let signer = ctx.accounts.signer.key();

        return Ok(contract._proposal_count);
    }

    pub fn get_proposal_votes(
        ctx: Context<GetProposalVotes>,
        proposal_id: u128,
    ) -> Result<(u128, u128)> {
        let contract = &mut ctx.accounts.contract;
        let signer = ctx.accounts.signer.key();

        return Ok((contract._proposal_yes_votes.iter().find(|(k, _)| k == &proposal_id).map(|(_, v)| *v).unwrap_or_default(), contract._proposal_no_votes.iter().find(|(k, _)| k == &proposal_id).map(|(_, v)| *v).unwrap_or_default()));
    }

    pub fn has_voted(
        ctx: Context<HasVoted>,
        proposal_id: u128,
        voter: Pubkey,
    ) -> Result<bool> {
        let contract = &mut ctx.accounts.contract;
        let signer = ctx.accounts.signer.key();

        return Ok(contract._has_voted.iter().find(|(k, _)| k == &proposal_id).and_then(|(_, inner)| inner.iter().find(|(k, _)| k == &voter).map(|(_, v)| *v)).unwrap_or_default());
    }

    pub fn get_voter_weight(
        ctx: Context<GetVoterWeight>,
        voter: Pubkey,
    ) -> Result<u128> {
        let contract = &mut ctx.accounts.contract;
        let signer = ctx.accounts.signer.key();

        return Ok(contract._voter_weights.iter().find(|(k, _)| k == &voter).map(|(_, v)| *v).unwrap_or_default());
    }

    pub fn create_proposal(
        ctx: Context<CreateProposal>,
        description: String,
    ) -> Result<()> {
        let contract = &mut ctx.accounts.contract;
        let signer = ctx.accounts.signer.key();

        require!((contract._voter_weights.iter().find(|(k, _)| k == &signer).map(|(_, v)| *v).unwrap_or_default() > 0), ErrorCode::InsufficientBalance);
        let proposal_id = contract._proposal_count;
        contract._proposal_count = (contract._proposal_count + 1);
        if let Some(entry) = contract._proposal_descriptions.iter_mut().find(|(k, _)| k == &proposal_id) {
            entry.1 = description;
        } else {
            contract._proposal_descriptions.push((proposal_id, description));
        }
        if let Some(entry) = contract._proposal_yes_votes.iter_mut().find(|(k, _)| k == &proposal_id) {
            entry.1 = 0;
        } else {
            contract._proposal_yes_votes.push((proposal_id, 0));
        }
        if let Some(entry) = contract._proposal_no_votes.iter_mut().find(|(k, _)| k == &proposal_id) {
            entry.1 = 0;
        } else {
            contract._proposal_no_votes.push((proposal_id, 0));
        }
        if let Some(entry) = contract._proposal_executed.iter_mut().find(|(k, _)| k == &proposal_id) {
            entry.1 = false;
        } else {
            contract._proposal_executed.push((proposal_id, false));
        }
        emit!(ProposalCreatedEvent {
            proposal_id: proposal_id,
            description: description,
            creator: signer,
        });
        Ok(())
    }

    pub fn vote(
        ctx: Context<Vote>,
        proposal_id: u128,
        support: bool,
    ) -> Result<()> {
        let contract = &mut ctx.accounts.contract;
        let signer = ctx.accounts.signer.key();

        require!((proposal_id < contract._proposal_count), ErrorCode::InsufficientBalance);
        require!((contract._has_voted.iter().find(|(k, _)| k == &proposal_id).and_then(|(_, inner)| inner.iter().find(|(k, _)| k == &signer).map(|(_, v)| *v)).unwrap_or_default() == false), ErrorCode::InsufficientAllowance);
        require!((contract._voter_weights.iter().find(|(k, _)| k == &signer).map(|(_, v)| *v).unwrap_or_default() > 0), ErrorCode::InsufficientBalance);
        require!((contract._proposal_executed.iter().find(|(k, _)| k == &proposal_id).map(|(_, v)| *v).unwrap_or_default() == false), ErrorCode::InsufficientBalance);
        let voter_weight = contract._voter_weights.iter().find(|(k, _)| k == &signer).map(|(_, v)| *v).unwrap_or_default();
        if let Some((_, inner)) = contract._has_voted.iter_mut().find(|(k, _)| k == &proposal_id) {
            if let Some(entry) = inner.iter_mut().find(|(k, _)| k == &signer) {
                entry.1 = true;
            } else {
                inner.push((signer, true));
            }
        } else {
            contract._has_voted.push((proposal_id, vec![(signer, true)]));
        }
        if support {
            let temp_value_12 = (contract._proposal_yes_votes.iter().find(|(k, _)| k == &proposal_id).map(|(_, v)| *v).unwrap_or_default() + voter_weight);
            if let Some(entry) = contract._proposal_yes_votes.iter_mut().find(|(k, _)| k == &proposal_id) {
                entry.1 = temp_value_12;
            } else {
                contract._proposal_yes_votes.push((proposal_id, temp_value_12));
            }
        } else {
            let temp_value_12 = (contract._proposal_no_votes.iter().find(|(k, _)| k == &proposal_id).map(|(_, v)| *v).unwrap_or_default() + voter_weight);
            if let Some(entry) = contract._proposal_no_votes.iter_mut().find(|(k, _)| k == &proposal_id) {
                entry.1 = temp_value_12;
            } else {
                contract._proposal_no_votes.push((proposal_id, temp_value_12));
            }
        }
        emit!(VotedEvent {
            proposal_id: proposal_id,
            voter: signer,
            vote: support,
        });
        Ok(())
    }

    pub fn execute_proposal(
        ctx: Context<ExecuteProposal>,
        proposal_id: u128,
    ) -> Result<()> {
        let contract = &mut ctx.accounts.contract;
        let signer = ctx.accounts.signer.key();

        require!((signer == contract._owner), ErrorCode::InsufficientAllowance);
        require!((proposal_id < contract._proposal_count), ErrorCode::InsufficientBalance);
        require!((contract._proposal_executed.iter().find(|(k, _)| k == &proposal_id).map(|(_, v)| *v).unwrap_or_default() == false), ErrorCode::InsufficientBalance);
        require!((contract._proposal_yes_votes.iter().find(|(k, _)| k == &proposal_id).map(|(_, v)| *v).unwrap_or_default() > contract._proposal_no_votes.iter().find(|(k, _)| k == &proposal_id).map(|(_, v)| *v).unwrap_or_default()), ErrorCode::InsufficientBalance);
        if let Some(entry) = contract._proposal_executed.iter_mut().find(|(k, _)| k == &proposal_id) {
            entry.1 = true;
        } else {
            contract._proposal_executed.push((proposal_id, true));
        }
        emit!(ProposalExecutedEvent {
            proposal_id: proposal_id,
        });
        Ok(())
    }

    pub fn set_voter_weight(
        ctx: Context<SetVoterWeight>,
        voter: Pubkey,
        weight: u128,
    ) -> Result<()> {
        let contract = &mut ctx.accounts.contract;
        let signer = ctx.accounts.signer.key();

        require!((signer == contract._owner), ErrorCode::InsufficientAllowance);
        require!((voter != Pubkey::default()), ErrorCode::ZeroAddress);
        if let Some(entry) = contract._voter_weights.iter_mut().find(|(k, _)| k == &voter) {
            entry.1 = weight;
        } else {
            contract._voter_weights.push((voter, weight));
        }
        Ok(())
    }

}

#[derive(Accounts)]
pub struct Initialize<'info> {
    #[account(
        init,
        payer = signer,
        space = 8 + 1024 // Discriminator + data
    )]
    pub contract: Account<'info, ContractState>,
    #[account(mut)]
    pub signer: Signer<'info>,
    pub system_program: Program<'info, System>,
}

#[derive(Accounts)]
pub struct GetProposalCount<'info> {
    pub contract: Account<'info, ContractState>,
    pub signer: Signer<'info>,
}

#[derive(Accounts)]
pub struct GetProposalVotes<'info> {
    pub contract: Account<'info, ContractState>,
    pub signer: Signer<'info>,
}

#[derive(Accounts)]
pub struct HasVoted<'info> {
    #[account(mut)]
    pub contract: Account<'info, ContractState>,
    pub signer: Signer<'info>,
}

#[derive(Accounts)]
pub struct GetVoterWeight<'info> {
    pub contract: Account<'info, ContractState>,
    pub signer: Signer<'info>,
}

#[derive(Accounts)]
pub struct CreateProposal<'info> {
    #[account(mut)]
    pub contract: Account<'info, ContractState>,
    pub signer: Signer<'info>,
}

#[derive(Accounts)]
pub struct Vote<'info> {
    #[account(mut)]
    pub contract: Account<'info, ContractState>,
    pub signer: Signer<'info>,
}

#[derive(Accounts)]
pub struct ExecuteProposal<'info> {
    #[account(mut)]
    pub contract: Account<'info, ContractState>,
    pub signer: Signer<'info>,
}

#[derive(Accounts)]
pub struct SetVoterWeight<'info> {
    #[account(mut)]
    pub contract: Account<'info, ContractState>,
    pub signer: Signer<'info>,
}

#[account]
pub struct ContractState {
    pub _proposal_yes_votes: Vec<(u128, u128)>,
    pub _has_voted: Vec<(u128, Vec<(Pubkey, bool)>)>,
    pub _voting_period: u128,
    pub _proposal_executed: Vec<(u128, bool)>,
    pub _owner: Pubkey,
    pub _proposal_no_votes: Vec<(u128, u128)>,
    pub _proposal_descriptions: Vec<(u128, String)>,
    pub _proposal_count: u128,
    pub _voter_weights: Vec<(Pubkey, u128)>,
}

#[event]
pub struct ProposalCreatedEvent {
    pub proposal_id: u128,
    pub description: String,
    pub creator: Pubkey,
}

#[event]
pub struct VotedEvent {
    pub proposal_id: u128,
    pub voter: Pubkey,
    pub vote: bool,
}

#[event]
pub struct ProposalExecutedEvent {
    pub proposal_id: u128,
}

#[error_code]
pub enum ErrorCode {
    #[msg("Insufficient balance")]
    InsufficientBalance,
    #[msg("Insufficient allowance")]
    InsufficientAllowance,
    #[msg("Cannot send to zero address")]
    ZeroAddress,
    #[msg("Cannot approve zero address")]
    ZeroApproval,
}
