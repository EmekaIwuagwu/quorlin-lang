// Generated by Quorlin compiler
// Target: Solana/Anchor

use anchor_lang::prelude::*;

declare_id!("Fg6PaFpoGXkYsidMpWTK6W2BeZ7FEfcYkg476zPFsLnS");

#[program]
pub mod simpletoken {
    use super::*;

    pub fn initialize(
        ctx: Context<Initialize>,
        name: String,
        symbol: String,
        decimals: u128,
        initial_supply: u128,
    ) -> Result<()> {
        let contract = &mut ctx.accounts.contract;
        let signer = ctx.accounts.signer.key();

        contract._name = name;
        contract._symbol = symbol;
        contract._decimals = decimals;
        contract._owner = signer;
        contract._total_supply = initial_supply;
        if let Some(entry) = contract._balances.iter_mut().find(|(k, _)| k == &signer) {
            entry.1 = initial_supply;
        } else {
            contract._balances.push((signer, initial_supply));
        }
        emit!(MintEvent {
            to: signer,
            amount: initial_supply,
        });
        emit!(TransferEvent {
            from_address: Pubkey::default(),
            to: signer,
            amount: initial_supply,
        });
        Ok(())
    }

    pub fn name(
        ctx: Context<Name>,
    ) -> Result<String> {
        let contract = &mut ctx.accounts.contract;
        let signer = ctx.accounts.signer.key();

        return Ok(contract._name);
    }

    pub fn symbol(
        ctx: Context<Symbol>,
    ) -> Result<String> {
        let contract = &mut ctx.accounts.contract;
        let signer = ctx.accounts.signer.key();

        return Ok(contract._symbol);
    }

    pub fn decimals(
        ctx: Context<Decimals>,
    ) -> Result<u128> {
        let contract = &mut ctx.accounts.contract;
        let signer = ctx.accounts.signer.key();

        return Ok(contract._decimals);
    }

    pub fn total_supply(
        ctx: Context<TotalSupply>,
    ) -> Result<u128> {
        let contract = &mut ctx.accounts.contract;
        let signer = ctx.accounts.signer.key();

        return Ok(contract._total_supply);
    }

    pub fn balance_of(
        ctx: Context<BalanceOf>,
        account: Pubkey,
    ) -> Result<u128> {
        let contract = &mut ctx.accounts.contract;
        let signer = ctx.accounts.signer.key();

        return Ok(contract._balances.iter().find(|(k, _)| k == &account).map(|(_, v)| *v).unwrap_or_default());
    }

    pub fn allowance(
        ctx: Context<Allowance>,
        owner: Pubkey,
        spender: Pubkey,
    ) -> Result<u128> {
        let contract = &mut ctx.accounts.contract;
        let signer = ctx.accounts.signer.key();

        return Ok(contract._allowances.iter().find(|(k, _)| k == &owner).and_then(|(_, inner)| inner.iter().find(|(k, _)| k == &spender).map(|(_, v)| *v)).unwrap_or_default());
    }

    pub fn transfer(
        ctx: Context<Transfer>,
        to: Pubkey,
        amount: u128,
    ) -> Result<()> {
        let contract = &mut ctx.accounts.contract;
        let signer = ctx.accounts.signer.key();

        require!((to != Pubkey::default()), ErrorCode::ZeroAddress);
        require!((contract._balances.iter().find(|(k, _)| k == &signer).map(|(_, v)| *v).unwrap_or_default() >= amount), ErrorCode::InsufficientBalance);
        let temp_value_8 = (contract._balances.iter().find(|(k, _)| k == &signer).map(|(_, v)| *v).unwrap_or_default() - amount);
        if let Some(entry) = contract._balances.iter_mut().find(|(k, _)| k == &signer) {
            entry.1 = temp_value_8;
        } else {
            contract._balances.push((signer, temp_value_8));
        }
        let temp_value_8 = (contract._balances.iter().find(|(k, _)| k == &to).map(|(_, v)| *v).unwrap_or_default() + amount);
        if let Some(entry) = contract._balances.iter_mut().find(|(k, _)| k == &to) {
            entry.1 = temp_value_8;
        } else {
            contract._balances.push((to, temp_value_8));
        }
        emit!(TransferEvent {
            from_address: signer,
            to: to,
            amount: amount,
        });
        Ok(())
    }

    pub fn approve(
        ctx: Context<Approve>,
        spender: Pubkey,
        amount: u128,
    ) -> Result<()> {
        let contract = &mut ctx.accounts.contract;
        let signer = ctx.accounts.signer.key();

        require!((spender != Pubkey::default()), ErrorCode::ZeroApproval);
        if let Some((_, inner)) = contract._allowances.iter_mut().find(|(k, _)| k == &signer) {
            if let Some(entry) = inner.iter_mut().find(|(k, _)| k == &spender) {
                entry.1 = amount;
            } else {
                inner.push((spender, amount));
            }
        } else {
            contract._allowances.push((signer, vec![(spender, amount)]));
        }
        emit!(ApprovalEvent {
            owner: signer,
            spender: spender,
            amount: amount,
        });
        Ok(())
    }

    pub fn transfer_from(
        ctx: Context<TransferFrom>,
        from_address: Pubkey,
        to: Pubkey,
        amount: u128,
    ) -> Result<()> {
        let contract = &mut ctx.accounts.contract;
        let signer = ctx.accounts.signer.key();

        require!((to != Pubkey::default()), ErrorCode::ZeroAddress);
        require!((contract._balances.iter().find(|(k, _)| k == &from_address).map(|(_, v)| *v).unwrap_or_default() >= amount), ErrorCode::InsufficientBalance);
        require!((contract._allowances.iter().find(|(k, _)| k == &from_address).and_then(|(_, inner)| inner.iter().find(|(k, _)| k == &signer).map(|(_, v)| *v)).unwrap_or_default() >= amount), ErrorCode::InsufficientAllowance);
        let temp_value_8 = (contract._balances.iter().find(|(k, _)| k == &from_address).map(|(_, v)| *v).unwrap_or_default() - amount);
        if let Some(entry) = contract._balances.iter_mut().find(|(k, _)| k == &from_address) {
            entry.1 = temp_value_8;
        } else {
            contract._balances.push((from_address, temp_value_8));
        }
        let temp_value_8 = (contract._balances.iter().find(|(k, _)| k == &to).map(|(_, v)| *v).unwrap_or_default() + amount);
        if let Some(entry) = contract._balances.iter_mut().find(|(k, _)| k == &to) {
            entry.1 = temp_value_8;
        } else {
            contract._balances.push((to, temp_value_8));
        }
        let temp_value_8 = (contract._allowances.iter().find(|(k, _)| k == &from_address).and_then(|(_, inner)| inner.iter().find(|(k, _)| k == &signer).map(|(_, v)| *v)).unwrap_or_default() - amount);
        if let Some((_, inner)) = contract._allowances.iter_mut().find(|(k, _)| k == &from_address) {
            if let Some(entry) = inner.iter_mut().find(|(k, _)| k == &signer) {
                entry.1 = temp_value_8;
            } else {
                inner.push((signer, temp_value_8));
            }
        } else {
            contract._allowances.push((from_address, vec![(signer, temp_value_8)]));
        }
        emit!(TransferEvent {
            from_address: from_address,
            to: to,
            amount: amount,
        });
        Ok(())
    }

    pub fn mint(
        ctx: Context<Mint>,
        to: Pubkey,
        amount: u128,
    ) -> Result<()> {
        let contract = &mut ctx.accounts.contract;
        let signer = ctx.accounts.signer.key();

        require!((signer == contract._owner), ErrorCode::InsufficientAllowance);
        require!((to != Pubkey::default()), ErrorCode::ZeroAddress);
        contract._total_supply = (contract._total_supply + amount);
        let temp_value_8 = (contract._balances.iter().find(|(k, _)| k == &to).map(|(_, v)| *v).unwrap_or_default() + amount);
        if let Some(entry) = contract._balances.iter_mut().find(|(k, _)| k == &to) {
            entry.1 = temp_value_8;
        } else {
            contract._balances.push((to, temp_value_8));
        }
        emit!(MintEvent {
            to: to,
            amount: amount,
        });
        emit!(TransferEvent {
            from_address: Pubkey::default(),
            to: to,
            amount: amount,
        });
        Ok(())
    }

}

#[derive(Accounts)]
pub struct Initialize<'info> {
    #[account(
        init,
        payer = signer,
        space = 8 + 1024 // Discriminator + data
    )]
    pub contract: Account<'info, ContractState>,
    #[account(mut)]
    pub signer: Signer<'info>,
    pub system_program: Program<'info, System>,
}

#[derive(Accounts)]
pub struct Name<'info> {
    #[account(mut)]
    pub contract: Account<'info, ContractState>,
    pub signer: Signer<'info>,
}

#[derive(Accounts)]
pub struct Symbol<'info> {
    #[account(mut)]
    pub contract: Account<'info, ContractState>,
    pub signer: Signer<'info>,
}

#[derive(Accounts)]
pub struct Decimals<'info> {
    #[account(mut)]
    pub contract: Account<'info, ContractState>,
    pub signer: Signer<'info>,
}

#[derive(Accounts)]
pub struct TotalSupply<'info> {
    #[account(mut)]
    pub contract: Account<'info, ContractState>,
    pub signer: Signer<'info>,
}

#[derive(Accounts)]
pub struct BalanceOf<'info> {
    pub contract: Account<'info, ContractState>,
    pub signer: Signer<'info>,
}

#[derive(Accounts)]
pub struct Allowance<'info> {
    pub contract: Account<'info, ContractState>,
    pub signer: Signer<'info>,
}

#[derive(Accounts)]
pub struct Transfer<'info> {
    #[account(mut)]
    pub contract: Account<'info, ContractState>,
    pub signer: Signer<'info>,
}

#[derive(Accounts)]
pub struct Approve<'info> {
    #[account(mut)]
    pub contract: Account<'info, ContractState>,
    pub signer: Signer<'info>,
}

#[derive(Accounts)]
pub struct TransferFrom<'info> {
    #[account(mut)]
    pub contract: Account<'info, ContractState>,
    pub signer: Signer<'info>,
}

#[derive(Accounts)]
pub struct Mint<'info> {
    #[account(mut)]
    pub contract: Account<'info, ContractState>,
    pub signer: Signer<'info>,
}

#[account]
pub struct ContractState {
    pub _balances: Vec<(Pubkey, u128)>,
    pub _allowances: Vec<(Pubkey, Vec<(Pubkey, u128)>)>,
    pub _symbol: String,
    pub _decimals: u128,
    pub _name: String,
    pub _owner: Pubkey,
    pub _total_supply: u128,
}

#[event]
pub struct TransferEvent {
    pub from_address: Pubkey,
    pub to: Pubkey,
    pub amount: u128,
}

#[event]
pub struct ApprovalEvent {
    pub owner: Pubkey,
    pub spender: Pubkey,
    pub amount: u128,
}

#[event]
pub struct MintEvent {
    pub to: Pubkey,
    pub amount: u128,
}

#[error_code]
pub enum ErrorCode {
    #[msg("Insufficient balance")]
    InsufficientBalance,
    #[msg("Insufficient allowance")]
    InsufficientAllowance,
    #[msg("Cannot send to zero address")]
    ZeroAddress,
    #[msg("Cannot approve zero address")]
    ZeroApproval,
}
