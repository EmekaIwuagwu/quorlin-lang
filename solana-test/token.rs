// Generated by Quorlin compiler
// Target: Solana/Anchor

use anchor_lang::prelude::*;

declare_id!("Fg6PaFpoGXkYsidMpWTK6W2BeZ7FEfcYkg476zPFsLnS");

#[program]
pub mod token {
    use super::*;

    pub fn initialize(
        ctx: Context<Initialize>,
        initial_supply: u128,
    ) -> Result<()> {
        let contract = &mut ctx.accounts.contract;

        contract.total_supply = initial_supply;
        contract.balances.insert(signer, initial_supply);
        emit!(TransferEvent {
            arg0: 0,
            arg1: signer,
            arg2: initial_supply,
        });
        Ok(())
    }

    pub fn transfer(
        ctx: Context<Transfer>,
        to: Pubkey,
        amount: u128,
    ) -> Result<bool> {
        let contract = &mut ctx.accounts.contract;
        let signer = ctx.accounts.signer.key();

        require!((contract.balances.get(&signer).cloned().unwrap_or_default() >= amount), "Insufficient balance");
        require!((to != 0), "Cannot send to zero address");
        contract.balances.insert(signer, contract.balances.get(&signer).cloned().unwrap_or_default().checked_sub(amount).expect("arithmetic underflow"));
        contract.balances.insert(to, contract.balances.get(&to).cloned().unwrap_or_default().checked_add(amount).expect("arithmetic overflow"));
        emit!(TransferEvent {
            arg0: signer,
            arg1: to,
            arg2: amount,
        });
        return Ok(true);
    }

    pub fn approve(
        ctx: Context<Approve>,
        spender: Pubkey,
        amount: u128,
    ) -> Result<bool> {
        let contract = &mut ctx.accounts.contract;
        let signer = ctx.accounts.signer.key();

        require!((spender != 0), "Cannot approve zero address");
        contract.allowances.entry(signer).or_insert_with(HashMap::new).insert(spender, amount);
        emit!(ApprovalEvent {
            arg0: signer,
            arg1: spender,
            arg2: amount,
        });
        return Ok(true);
    }

    pub fn transfer_from(
        ctx: Context<TransferFrom>,
        from_addr: Pubkey,
        to: Pubkey,
        amount: u128,
    ) -> Result<bool> {
        let contract = &mut ctx.accounts.contract;
        let signer = ctx.accounts.signer.key();

        require!((contract.balances.get(&from_addr).cloned().unwrap_or_default() >= amount), "Insufficient balance");
        require!((contract.allowances.get(&from_addr).and_then(|inner| inner.get(&signer)).cloned().unwrap_or_default() >= amount), "Insufficient allowance");
        require!((to != 0), "Cannot send to zero address");
        contract.balances.insert(from_addr, contract.balances.get(&from_addr).cloned().unwrap_or_default().checked_sub(amount).expect("arithmetic underflow"));
        contract.balances.insert(to, contract.balances.get(&to).cloned().unwrap_or_default().checked_add(amount).expect("arithmetic overflow"));
        contract.allowances.entry(from_addr).or_insert_with(HashMap::new).insert(signer, (contract.allowances.get(&from_addr).and_then(|inner| inner.get(&signer)).cloned().unwrap_or_default() - amount));
        emit!(TransferEvent {
            arg0: from_addr,
            arg1: to,
            arg2: amount,
        });
        return Ok(true);
    }

    pub fn balance_of(
        ctx: Context<BalanceOf>,
        owner: Pubkey,
    ) -> Result<u128> {
        let contract = &mut ctx.accounts.contract;
        let signer = ctx.accounts.signer.key();

        return Ok(contract.balances.get(&owner).cloned().unwrap_or_default());
    }

    pub fn allowance(
        ctx: Context<Allowance>,
        owner: Pubkey,
        spender: Pubkey,
    ) -> Result<u128> {
        let contract = &mut ctx.accounts.contract;
        let signer = ctx.accounts.signer.key();

        return Ok(contract.allowances.get(&owner).and_then(|inner| inner.get(&spender)).cloned().unwrap_or_default());
    }

    pub fn get_total_supply(
        ctx: Context<GetTotalSupply>,
    ) -> Result<u128> {
        let contract = &mut ctx.accounts.contract;
        let signer = ctx.accounts.signer.key();

        return Ok(contract.total_supply);
    }

}

#[derive(Accounts)]
pub struct Initialize<'info> {
    #[account(
        init,
        payer = signer,
        space = 8 + 1024 // Discriminator + data
    )]
    pub contract: Account<'info, ContractState>,
    #[account(mut)]
    pub signer: Signer<'info>,
    pub system_program: Program<'info, System>,
}

#[derive(Accounts)]
pub struct ExecuteInstruction<'info> {
    #[account(mut)]
    pub contract: Account<'info, ContractState>,
    pub signer: Signer<'info>,
}

#[account]
pub struct ContractState {
    pub name: String,
    pub decimals: u8,
    pub symbol: String,
    pub total_supply: u128,
    pub balances: HashMap<Pubkey, u128>,
    pub allowances: HashMap<Pubkey, HashMap<Pubkey, u128>>,
}

#[event]
pub struct TransferEvent {
    pub from_addr: Pubkey,
    pub to_addr: Pubkey,
    pub value: u128,
}

#[event]
pub struct ApprovalEvent {
    pub owner: Pubkey,
    pub spender: Pubkey,
    pub value: u128,
}

