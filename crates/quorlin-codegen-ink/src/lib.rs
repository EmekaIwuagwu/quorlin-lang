//! # Quorlin ink! Codegen
//!
//! ink! Wasm code generator for the Quorlin compiler.
//!
//! This crate generates ink! Rust code for Polkadot contracts from Quorlin AST.

use quorlin_parser::{Module, ContractMember, Expr, Stmt, BinOp, Type};
use std::collections::HashMap;

/// Errors that can occur during ink! code generation
#[derive(Debug, thiserror::Error)]
pub enum CodegenError {
    #[error("Codegen error: {0}")]
    Error(String),

    #[error("Unsupported feature: {0}")]
    UnsupportedFeature(String),

    #[error("Contract not found")]
    ContractNotFound,
}

/// Result type for code generation
pub type CodegenResult<T> = Result<T, CodegenError>;

/// ink! code generator
pub struct InkCodegen {
    /// Storage fields derived from state variables
    storage_fields: HashMap<String, String>,

    /// Event definitions
    events: Vec<EventInfo>,

    /// Current contract name
    contract_name: String,
}

#[derive(Debug, Clone)]
struct EventInfo {
    name: String,
    params: Vec<(String, String)>, // (name, type)
}

impl InkCodegen {
    /// Create a new ink! code generator
    pub fn new() -> Self {
        Self {
            storage_fields: HashMap::new(),
            events: Vec::new(),
            contract_name: String::new(),
        }
    }

    /// Generate ink! Rust code from a module
    pub fn generate(&mut self, module: &Module) -> CodegenResult<String> {
        // Find the contract
        let contract = module
            .items
            .iter()
            .find_map(|item| {
                if let quorlin_parser::Item::Contract(c) = item {
                    Some(c)
                } else {
                    None
                }
            })
            .ok_or(CodegenError::ContractNotFound)?;

        self.contract_name = contract.name.clone();

        // Collect events
        self.collect_events(module)?;

        // Collect state variables for storage structure
        self.collect_state_vars(&contract.body)?;

        // Generate ink! code
        let mut code = String::new();

        // File header
        code.push_str(&self.generate_header());

        // Contract module
        code.push_str("#[ink::contract]\n");
        code.push_str(&format!("mod {} {{\n", self.contract_name.to_lowercase()));
        code.push_str("    use ink::prelude::*;\n");
        code.push_str("    use ink::storage::Mapping;\n\n");

        // Storage structure
        code.push_str(&self.generate_storage()?);

        // Events
        code.push_str(&self.generate_events()?);

        // Implementation block
        code.push_str(&format!("    impl {} {{\n", self.contract_name));

        // Constructor
        code.push_str(&self.generate_constructor(&contract.body)?);

        // Messages (functions)
        code.push_str(&self.generate_messages(&contract.body)?);

        code.push_str("    }\n"); // Close impl block
        code.push_str("}\n"); // Close mod

        Ok(code)
    }

    /// Generate file header with imports
    fn generate_header(&self) -> String {
        let mut code = String::new();
        code.push_str("// Generated by Quorlin compiler\n");
        code.push_str("// Target: Polkadot/ink!\n\n");
        code.push_str("#![cfg_attr(not(feature = \"std\"), no_std, no_main)]\n\n");
        code
    }

    /// Collect event definitions
    fn collect_events(&mut self, module: &Module) -> CodegenResult<()> {
        for item in &module.items {
            if let quorlin_parser::Item::Event(event) = item {
                let params: Vec<_> = event.params.iter()
                    .map(|p| (p.name.clone(), self.map_type(&p.type_annotation)))
                    .collect();

                self.events.push(EventInfo {
                    name: event.name.clone(),
                    params,
                });
            }
        }
        Ok(())
    }

    /// Collect state variables for storage structure
    fn collect_state_vars(&mut self, members: &[ContractMember]) -> CodegenResult<()> {
        for member in members {
            if let ContractMember::StateVar(var) = member {
                let ink_type = self.map_type(&var.type_annotation);
                self.storage_fields.insert(var.name.clone(), ink_type);
            }
        }
        Ok(())
    }

    /// Map Quorlin types to ink! types
    fn map_type(&self, ty: &Type) -> String {
        match ty {
            Type::Simple(s) => match s.as_str() {
                "uint8" => "u8".to_string(),
                "uint16" => "u16".to_string(),
                "uint32" => "u32".to_string(),
                "uint64" => "u64".to_string(),
                "uint128" => "u128".to_string(),
                "uint256" => "U256".to_string(), // ink! supports U256 from scale_info
                "int8" => "i8".to_string(),
                "int16" => "i16".to_string(),
                "int32" => "i32".to_string(),
                "int64" => "i64".to_string(),
                "int128" => "i128".to_string(),
                "int256" => "I256".to_string(),
                "bool" => "bool".to_string(),
                "address" => "AccountId".to_string(),
                "str" => "String".to_string(),
                "bytes" => "Vec<u8>".to_string(),
                _ => s.clone(),
            },
            Type::Mapping(key, val) => {
                format!("Mapping<{}, {}>", self.map_type(key), self.map_type(val))
            }
            Type::List(inner) => {
                format!("Vec<{}>", self.map_type(inner))
            }
            Type::FixedArray(inner, size) => {
                format!("[{}; {}]", self.map_type(inner), size)
            }
            Type::Optional(inner) => {
                format!("Option<{}>", self.map_type(inner))
            }
            Type::Tuple(types) => {
                let type_strs: Vec<_> = types.iter().map(|t| self.map_type(t)).collect();
                format!("({})", type_strs.join(", "))
            }
        }
    }

    /// Generate storage structure
    fn generate_storage(&self) -> CodegenResult<String> {
        let mut code = String::new();

        code.push_str("    #[ink(storage)]\n");
        code.push_str(&format!("    pub struct {} {{\n", self.contract_name));

        for (name, ty) in &self.storage_fields {
            code.push_str(&format!("        {}: {},\n", name, ty));
        }

        code.push_str("    }\n\n");

        Ok(code)
    }

    /// Generate event structures
    fn generate_events(&self) -> CodegenResult<String> {
        let mut code = String::new();

        for event in &self.events {
            code.push_str("    #[ink(event)]\n");
            code.push_str(&format!("    pub struct {} {{\n", event.name));

            for (i, (name, ty)) in event.params.iter().enumerate() {
                if i == 0 {
                    code.push_str("        #[ink(topic)]\n");
                }
                code.push_str(&format!("        pub {}: {},\n", name, ty));
            }

            code.push_str("    }\n\n");
        }

        Ok(code)
    }

    /// Generate constructor
    fn generate_constructor(&self, members: &[ContractMember]) -> CodegenResult<String> {
        let mut code = String::new();

        // Find the __init__ function
        let init_func = members.iter().find_map(|m| {
            if let ContractMember::Function(f) = m {
                if f.name == "__init__" {
                    Some(f)
                } else {
                    None
                }
            } else {
                None
            }
        });

        if let Some(func) = init_func {
            code.push_str("        #[ink(constructor)]\n");
            code.push_str("        pub fn new(");

            // Parameters
            for (i, param) in func.params.iter().enumerate() {
                if i > 0 {
                    code.push_str(", ");
                }
                let rust_type = self.map_type(&param.type_annotation);
                code.push_str(&format!("{}: {}", param.name, rust_type));
            }

            code.push_str(") -> Self {\n");

            // Initialize storage fields
            code.push_str("            let mut instance = Self {\n");
            for (name, _) in &self.storage_fields {
                code.push_str(&format!("                {}: Default::default(),\n", name));
            }
            code.push_str("            };\n\n");

            // Constructor body
            for stmt in &func.body {
                code.push_str(&self.generate_statement(stmt, 12, true)?);
            }

            code.push_str("            instance\n");
            code.push_str("        }\n\n");
        }

        Ok(code)
    }

    /// Generate message functions
    fn generate_messages(&self, members: &[ContractMember]) -> CodegenResult<String> {
        let mut code = String::new();

        for member in members {
            if let ContractMember::Function(func) = member {
                // Skip constructor
                if func.name == "__init__" {
                    continue;
                }

                // Determine if it's a view function
                let is_view = func.decorators.contains(&"view".to_string());

                // Function signature
                code.push_str("        #[ink(message");
                if !is_view {
                    code.push_str(")]\n");
                } else {
                    code.push_str(")]\n");
                }

                code.push_str(&format!("        pub fn {}(", func.name));

                // Add &self or &mut self
                if is_view {
                    code.push_str("&self");
                } else {
                    code.push_str("&mut self");
                }

                // Parameters
                for param in &func.params {
                    let rust_type = self.map_type(&param.type_annotation);
                    code.push_str(&format!(", {}: {}", param.name, rust_type));
                }

                code.push_str(")");

                // Return type
                if let Some(ret_type) = &func.return_type {
                    code.push_str(&format!(" -> {}", self.map_type(ret_type)));
                }

                code.push_str(" {\n");

                // Function body
                for stmt in &func.body {
                    code.push_str(&self.generate_statement(stmt, 12, false)?);
                }

                // If function has return type and no explicit return, add default
                if func.return_type.is_some() && !self.has_return_stmt(&func.body) {
                    code.push_str("            Default::default()\n");
                }

                code.push_str("        }\n\n");
            }
        }

        Ok(code)
    }

    /// Check if statements contain a return
    fn has_return_stmt(&self, stmts: &[Stmt]) -> bool {
        stmts.iter().any(|s| matches!(s, Stmt::Return(_)))
    }

    /// Generate statement code
    fn generate_statement(&self, stmt: &Stmt, indent: usize, in_constructor: bool) -> CodegenResult<String> {
        let indent_str = " ".repeat(indent);
        let mut code = String::new();

        match stmt {
            Stmt::Return(expr) => {
                if let Some(e) = expr {
                    let expr_code = self.generate_expression(e, in_constructor)?;
                    code.push_str(&format!("{}return {};\n", indent_str, expr_code));
                } else {
                    code.push_str(&format!("{}return;\n", indent_str));
                }
            }
            Stmt::Assign(assign) => {
                let value_code = self.generate_expression(&assign.value, in_constructor)?;

                match &assign.target {
                    Expr::Ident(name) => {
                        code.push_str(&format!("{}let {} = {};\n", indent_str, name, value_code));
                    }
                    Expr::Attribute(base, attr) => {
                        if let Expr::Ident(base_name) = &**base {
                            if base_name == "self" {
                                let prefix = if in_constructor { "instance" } else { "self" };
                                code.push_str(&format!("{}{}.{} = {};\n", indent_str, prefix, attr, value_code));
                            }
                        }
                    }
                    Expr::Index(target, index) => {
                        // Handle nested mapping assignment
                        if let Expr::Index(nested_target, nested_index) = &**target {
                            if let Expr::Attribute(base, attr) = &**nested_target {
                                if let Expr::Ident(base_name) = &**base {
                                    if base_name == "self" {
                                        let first_key = self.generate_expression(nested_index, in_constructor)?;
                                        let second_key = self.generate_expression(index, in_constructor)?;
                                        let prefix = if in_constructor { "instance" } else { "self" };
                                        // Note: This is a simplified approach for nested mappings
                                        code.push_str(&format!("{}// Nested mapping assignment\n", indent_str));
                                        code.push_str(&format!("{}{}.{}.get_or_insert_default({}).insert({}, &{});\n",
                                            indent_str, prefix, attr, first_key, second_key, value_code));
                                    }
                                }
                            }
                        } else if let Expr::Attribute(base, attr) = &**target {
                            // Simple mapping assignment
                            if let Expr::Ident(base_name) = &**base {
                                if base_name == "self" {
                                    let key_code = self.generate_expression(index, in_constructor)?;
                                    let prefix = if in_constructor { "instance" } else { "self" };
                                    code.push_str(&format!("{}{}.{}.insert({}, &{});\n",
                                        indent_str, prefix, attr, key_code, value_code));
                                }
                            }
                        }
                    }
                    _ => {
                        return Err(CodegenError::UnsupportedFeature(format!("Assignment target {:?}", assign.target)));
                    }
                }
            }
            Stmt::Require(req) => {
                let cond = self.generate_expression(&req.condition, in_constructor)?;
                if let Some(msg) = &req.message {
                    code.push_str(&format!("{}assert!({}, \"{}\");\n", indent_str, cond, msg));
                } else {
                    code.push_str(&format!("{}assert!({});\n", indent_str, cond));
                }
            }
            Stmt::Emit(emit) => {
                // Emit event
                let prefix = if in_constructor { "Self" } else { "self" };
                code.push_str(&format!("{}{}::env().emit_event({} {{\n", indent_str, prefix, emit.event));

                // Event fields
                if let Some(event_info) = self.events.iter().find(|e| e.name == emit.event) {
                    for (i, arg) in emit.args.iter().enumerate() {
                        let arg_code = self.generate_expression(arg, in_constructor)?;
                        if i < event_info.params.len() {
                            code.push_str(&format!("{}    {}: {},\n", indent_str, event_info.params[i].0, arg_code));
                        }
                    }
                }

                code.push_str(&format!("{}}});\n", indent_str));
            }
            Stmt::If(if_stmt) => {
                let cond = self.generate_expression(&if_stmt.condition, in_constructor)?;
                code.push_str(&format!("{}if {} {{\n", indent_str, cond));

                for s in &if_stmt.then_branch {
                    code.push_str(&self.generate_statement(s, indent + 4, in_constructor)?);
                }

                // Elif branches
                for (elif_cond, elif_body) in &if_stmt.elif_branches {
                    let elif_cond_code = self.generate_expression(elif_cond, in_constructor)?;
                    code.push_str(&format!("{}}} else if {} {{\n", indent_str, elif_cond_code));
                    for s in elif_body {
                        code.push_str(&self.generate_statement(s, indent + 4, in_constructor)?);
                    }
                }

                // Else branch
                if let Some(else_body) = &if_stmt.else_branch {
                    code.push_str(&format!("{}}} else {{\n", indent_str));
                    for s in else_body {
                        code.push_str(&self.generate_statement(s, indent + 4, in_constructor)?);
                    }
                }

                code.push_str(&format!("{}}}\n", indent_str));
            }
            Stmt::While(while_stmt) => {
                let cond = self.generate_expression(&while_stmt.condition, in_constructor)?;
                code.push_str(&format!("{}while {} {{\n", indent_str, cond));

                for s in &while_stmt.body {
                    code.push_str(&self.generate_statement(s, indent + 4, in_constructor)?);
                }

                code.push_str(&format!("{}}}\n", indent_str));
            }
            Stmt::Pass => {
                code.push_str(&format!("{}// pass\n", indent_str));
            }
            _ => {
                return Err(CodegenError::UnsupportedFeature(format!("Statement {:?}", stmt)));
            }
        }

        Ok(code)
    }

    /// Generate expression code
    fn generate_expression(&self, expr: &Expr, in_constructor: bool) -> CodegenResult<String> {
        match expr {
            Expr::IntLiteral(n) => Ok(n.clone()),
            Expr::BoolLiteral(b) => Ok(b.to_string()),
            Expr::StringLiteral(s) => Ok(format!("String::from(\"{}\")", s)),
            Expr::Ident(name) => {
                // Check if it's a state variable
                if self.storage_fields.contains_key(name) {
                    let prefix = if in_constructor { "instance" } else { "self" };
                    Ok(format!("{}.{}", prefix, name))
                } else {
                    Ok(name.clone())
                }
            }
            Expr::BinOp(left, op, right) => {
                let left_code = self.generate_expression(left, in_constructor)?;
                let right_code = self.generate_expression(right, in_constructor)?;

                let op_str = match op {
                    BinOp::Add => "+",
                    BinOp::Sub => "-",
                    BinOp::Mul => "*",
                    BinOp::Div => "/",
                    BinOp::Mod => "%",
                    BinOp::Eq => "==",
                    BinOp::NotEq => "!=",
                    BinOp::Lt => "<",
                    BinOp::Gt => ">",
                    BinOp::LtEq => "<=",
                    BinOp::GtEq => ">=",
                    BinOp::And => "&&",
                    BinOp::Or => "||",
                    _ => return Err(CodegenError::UnsupportedFeature(format!("BinOp {:?}", op))),
                };

                Ok(format!("({} {} {})", left_code, op_str, right_code))
            }
            Expr::Call(func, args) => {
                if let Expr::Ident(func_name) = &**func {
                    let arg_codes: Vec<_> = args.iter()
                        .map(|a| self.generate_expression(a, in_constructor))
                        .collect::<Result<_, _>>()?;

                    match func_name.as_str() {
                        "address" => {
                            if args.len() == 1 {
                                Ok(arg_codes[0].clone())
                            } else {
                                Err(CodegenError::UnsupportedFeature("address() requires 1 argument".to_string()))
                            }
                        }
                        "safe_add" => Ok(format!("{}.checked_add({}).expect(\"arithmetic overflow\")", arg_codes[0], arg_codes[1])),
                        "safe_sub" => Ok(format!("{}.checked_sub({}).expect(\"arithmetic underflow\")", arg_codes[0], arg_codes[1])),
                        _ => Ok(format!("{}({})", func_name, arg_codes.join(", "))),
                    }
                } else {
                    Err(CodegenError::UnsupportedFeature("Complex function calls".to_string()))
                }
            }
            Expr::Attribute(base, attr) => {
                if let Expr::Ident(base_name) = &**base {
                    if base_name == "msg" && attr == "sender" {
                        let prefix = if in_constructor { "Self" } else { "self" };
                        return Ok(format!("{}::env().caller()", prefix));
                    } else if base_name == "self" {
                        let prefix = if in_constructor { "instance" } else { "self" };
                        return Ok(format!("{}.{}", prefix, attr));
                    }
                }
                Err(CodegenError::UnsupportedFeature(format!("Attribute {}.{}", "base", attr)))
            }
            Expr::Index(target, index) => {
                // Handle nested indexing: self.allowances[key1][key2]
                if let Expr::Index(nested_target, nested_index) = &**target {
                    // Nested mapping access
                    if let Expr::Attribute(base, attr) = &**nested_target {
                        if let Expr::Ident(base_name) = &**base {
                            if base_name == "self" {
                                let first_key = self.generate_expression(nested_index, in_constructor)?;
                                let second_key = self.generate_expression(index, in_constructor)?;
                                let prefix = if in_constructor { "instance" } else { "self" };
                                // Note: ink! nested mappings would need different handling in real impl
                                // For now, we'll flatten it or use a workaround
                                return Ok(format!(
                                    "{}.{}.get({}).and_then(|inner| inner.get({})).unwrap_or_default()",
                                    prefix, attr, first_key, second_key
                                ));
                            }
                        }
                    }
                } else if let Expr::Attribute(base, attr) = &**target {
                    // Simple mapping access
                    if let Expr::Ident(base_name) = &**base {
                        if base_name == "self" {
                            let key_code = self.generate_expression(index, in_constructor)?;
                            let prefix = if in_constructor { "instance" } else { "self" };
                            return Ok(format!("{}.{}.get({}).unwrap_or_default()", prefix, attr, key_code));
                        }
                    }
                }
                Err(CodegenError::UnsupportedFeature(format!("Index {:?}", expr)))
            }
            _ => Err(CodegenError::UnsupportedFeature(format!("Expression {:?}", expr))),
        }
    }
}

impl Default for InkCodegen {
    fn default() -> Self {
        Self::new()
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_codegen_creation() {
        let _codegen = InkCodegen::new();
    }

    #[test]
    fn test_type_mapping() {
        let codegen = InkCodegen::new();
        assert_eq!(codegen.map_type(&Type::Simple("uint256".to_string())), "U256");
        assert_eq!(codegen.map_type(&Type::Simple("address".to_string())), "AccountId");
        assert_eq!(codegen.map_type(&Type::Simple("bool".to_string())), "bool");
    }
}
