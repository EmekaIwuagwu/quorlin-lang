//! # Quorlin Solana Codegen
//!
//! Solana BPF code generator for the Quorlin compiler.
//!
//! This crate generates Rust/Anchor code from Quorlin AST for Solana programs.

use quorlin_parser::{Module, ContractMember, Expr, Stmt, BinOp, Type};
use std::collections::HashMap;

/// Errors that can occur during Solana code generation
#[derive(Debug, thiserror::Error)]
pub enum CodegenError {
    #[error("Codegen error: {0}")]
    Error(String),

    #[error("Unsupported feature: {0}")]
    UnsupportedFeature(String),

    #[error("Contract not found")]
    ContractNotFound,
}

/// Result type for code generation
pub type CodegenResult<T> = Result<T, CodegenError>;

/// Solana/Anchor code generator
pub struct SolanaCodegen {
    /// Account fields derived from state variables
    account_fields: HashMap<String, String>,

    /// Event definitions
    events: Vec<EventInfo>,

    /// Current contract name
    contract_name: String,
}

#[derive(Debug, Clone)]
struct EventInfo {
    name: String,
    params: Vec<(String, String)>, // (name, type)
}

impl SolanaCodegen {
    /// Create a new Solana code generator
    pub fn new() -> Self {
        Self {
            account_fields: HashMap::new(),
            events: Vec::new(),
            contract_name: String::new(),
        }
    }

    /// Generate Anchor/Rust code from a module
    pub fn generate(&mut self, module: &Module) -> CodegenResult<String> {
        // Find the contract
        let contract = module
            .items
            .iter()
            .find_map(|item| {
                if let quorlin_parser::Item::Contract(c) = item {
                    Some(c)
                } else {
                    None
                }
            })
            .ok_or(CodegenError::ContractNotFound)?;

        self.contract_name = contract.name.clone();

        // Collect events
        self.collect_events(module)?;

        // Collect state variables for account structure
        self.collect_state_vars(&contract.body)?;

        // Generate Rust/Anchor code
        let mut code = String::new();

        // File header
        code.push_str(&self.generate_header());

        // Program module
        code.push_str(&format!("#[program]\npub mod {} {{\n", self.contract_name.to_lowercase()));
        code.push_str("    use super::*;\n\n");

        // Generate initialize function (constructor)
        code.push_str(&self.generate_initialize(&contract.body)?);

        // Generate instruction handlers (functions)
        code.push_str(&self.generate_instructions(&contract.body)?);

        code.push_str("}\n\n");

        // Generate account structures
        code.push_str(&self.generate_accounts()?);

        // Generate events
        code.push_str(&self.generate_events()?);

        Ok(code)
    }

    /// Generate file header with imports
    fn generate_header(&self) -> String {
        let mut code = String::new();
        code.push_str("// Generated by Quorlin compiler\n");
        code.push_str("// Target: Solana/Anchor\n\n");
        code.push_str("use anchor_lang::prelude::*;\n\n");
        code.push_str("declare_id!(\"Fg6PaFpoGXkYsidMpWTK6W2BeZ7FEfcYkg476zPFsLnS\");\n\n");
        code
    }

    /// Collect event definitions
    fn collect_events(&mut self, module: &Module) -> CodegenResult<()> {
        for item in &module.items {
            if let quorlin_parser::Item::Event(event) = item {
                let params: Vec<_> = event.params.iter()
                    .map(|p| (p.name.clone(), self.map_type(&p.type_annotation)))
                    .collect();

                self.events.push(EventInfo {
                    name: event.name.clone(),
                    params,
                });
            }
        }
        Ok(())
    }

    /// Collect state variables for account structure
    fn collect_state_vars(&mut self, members: &[ContractMember]) -> CodegenResult<()> {
        for member in members {
            if let ContractMember::StateVar(var) = member {
                let rust_type = self.map_type(&var.type_annotation);
                self.account_fields.insert(var.name.clone(), rust_type);
            }
        }
        Ok(())
    }

    /// Map Quorlin types to Solana/Rust types
    fn map_type(&self, ty: &Type) -> String {
        match ty {
            Type::Simple(s) => match s.as_str() {
                "uint8" => "u8".to_string(),
                "uint16" => "u16".to_string(),
                "uint32" => "u32".to_string(),
                "uint64" => "u64".to_string(),
                "uint128" => "u128".to_string(),
                "uint256" => "u128".to_string(), // Solana doesn't have u256, use u128
                "int8" => "i8".to_string(),
                "int16" => "i16".to_string(),
                "int32" => "i32".to_string(),
                "int64" => "i64".to_string(),
                "int128" => "i128".to_string(),
                "int256" => "i128".to_string(),
                "bool" => "bool".to_string(),
                "address" => "Pubkey".to_string(),
                "str" => "String".to_string(),
                "bytes" => "Vec<u8>".to_string(),
                _ => s.clone(),
            },
            Type::Mapping(key, val) => {
                // Mappings in Solana are typically handled via PDAs or HashMap in account data
                format!("HashMap<{}, {}>", self.map_type(key), self.map_type(val))
            }
            Type::List(inner) => {
                format!("Vec<{}>", self.map_type(inner))
            }
            Type::FixedArray(inner, size) => {
                format!("[{}; {}]", self.map_type(inner), size)
            }
            Type::Optional(inner) => {
                format!("Option<{}>", self.map_type(inner))
            }
            Type::Tuple(types) => {
                let type_strs: Vec<_> = types.iter().map(|t| self.map_type(t)).collect();
                format!("({})", type_strs.join(", "))
            }
        }
    }

    /// Generate initialize function (constructor)
    fn generate_initialize(&self, members: &[ContractMember]) -> CodegenResult<String> {
        let mut code = String::new();

        // Find the __init__ function
        let init_func = members.iter().find_map(|m| {
            if let ContractMember::Function(f) = m {
                if f.name == "__init__" {
                    Some(f)
                } else {
                    None
                }
            } else {
                None
            }
        });

        if let Some(func) = init_func {
            code.push_str("    pub fn initialize(\n");
            code.push_str("        ctx: Context<Initialize>,\n");

            // Add parameters
            for param in &func.params {
                let rust_type = self.map_type(&param.type_annotation);
                code.push_str(&format!("        {}: {},\n", param.name, rust_type));
            }

            code.push_str("    ) -> Result<()> {\n");
            code.push_str("        let contract = &mut ctx.accounts.contract;\n\n");

            // Generate function body
            for stmt in &func.body {
                code.push_str(&self.generate_statement(stmt, 8)?);
            }

            code.push_str("        Ok(())\n");
            code.push_str("    }\n\n");
        }

        Ok(code)
    }

    /// Generate instruction handlers (functions)
    fn generate_instructions(&self, members: &[ContractMember]) -> CodegenResult<String> {
        let mut code = String::new();

        for member in members {
            if let ContractMember::Function(func) = member {
                // Skip constructor
                if func.name == "__init__" {
                    continue;
                }

                // Function signature
                code.push_str(&format!("    pub fn {}(\n", func.name));
                code.push_str(&format!("        ctx: Context<{}>,\n",
                    self.to_pascal_case(&func.name)));

                // Parameters
                for param in &func.params {
                    let rust_type = self.map_type(&param.type_annotation);
                    code.push_str(&format!("        {}: {},\n", param.name, rust_type));
                }

                code.push_str("    ) -> Result<");
                if let Some(ret_type) = &func.return_type {
                    code.push_str(&self.map_type(ret_type));
                } else {
                    code.push_str("()");
                }
                code.push_str("> {\n");

                code.push_str("        let contract = &mut ctx.accounts.contract;\n");
                code.push_str(&format!("        let signer = ctx.accounts.signer.key();\n\n"));

                // Function body
                for stmt in &func.body {
                    code.push_str(&self.generate_statement(stmt, 8)?);
                }

                // If function has return type and no explicit return, add default
                if func.return_type.is_some() && !self.has_return_stmt(&func.body) {
                    code.push_str("        Ok(Default::default())\n");
                } else if func.return_type.is_none() {
                    code.push_str("        Ok(())\n");
                }

                code.push_str("    }\n\n");
            }
        }

        Ok(code)
    }

    /// Check if statements contain a return
    fn has_return_stmt(&self, stmts: &[Stmt]) -> bool {
        stmts.iter().any(|s| matches!(s, Stmt::Return(_)))
    }

    /// Generate statement code
    fn generate_statement(&self, stmt: &Stmt, indent: usize) -> CodegenResult<String> {
        let indent_str = " ".repeat(indent);
        let mut code = String::new();

        match stmt {
            Stmt::Return(expr) => {
                if let Some(e) = expr {
                    let expr_code = self.generate_expression(e)?;
                    code.push_str(&format!("{}return Ok({});\n", indent_str, expr_code));
                } else {
                    code.push_str(&format!("{}return Ok(());\n", indent_str));
                }
            }
            Stmt::Assign(assign) => {
                let value_code = self.generate_expression(&assign.value)?;

                match &assign.target {
                    Expr::Ident(name) => {
                        code.push_str(&format!("{}let {} = {};\n", indent_str, name, value_code));
                    }
                    Expr::Attribute(base, attr) => {
                        if let Expr::Ident(base_name) = &**base {
                            if base_name == "self" {
                                code.push_str(&format!("{}contract.{} = {};\n", indent_str, attr, value_code));
                            }
                        }
                    }
                    Expr::Index(target, index) => {
                        // Handle nested mapping assignment
                        if let Expr::Index(nested_target, nested_index) = &**target {
                            if let Expr::Attribute(base, attr) = &**nested_target {
                                if let Expr::Ident(base_name) = &**base {
                                    if base_name == "self" {
                                        let first_key = self.generate_expression(nested_index)?;
                                        let second_key = self.generate_expression(index)?;
                                        code.push_str(&format!("{}contract.{}.entry({}).or_insert_with(HashMap::new).insert({}, {});\n",
                                            indent_str, attr, first_key, second_key, value_code));
                                    }
                                }
                            }
                        } else if let Expr::Attribute(base, attr) = &**target {
                            // Simple mapping assignment
                            if let Expr::Ident(base_name) = &**base {
                                if base_name == "self" {
                                    let key_code = self.generate_expression(index)?;
                                    code.push_str(&format!("{}contract.{}.insert({}, {});\n",
                                        indent_str, attr, key_code, value_code));
                                }
                            }
                        }
                    }
                    _ => {
                        return Err(CodegenError::UnsupportedFeature(format!("Assignment target {:?}", assign.target)));
                    }
                }
            }
            Stmt::Require(req) => {
                let cond = self.generate_expression(&req.condition)?;
                if let Some(msg) = &req.message {
                    code.push_str(&format!("{}require!({}, \"{}\");\n", indent_str, cond, msg));
                } else {
                    code.push_str(&format!("{}require!({});\n", indent_str, cond));
                }
            }
            Stmt::Emit(emit) => {
                // Emit event using msg! macro or custom event
                code.push_str(&format!("{}emit!({}Event {{\n", indent_str, emit.event));

                // Find the event definition to get proper field names
                let event_info = self.events.iter()
                    .find(|e| e.name == emit.event)
                    .ok_or_else(|| CodegenError::Error(format!("Event '{}' not found", emit.event)))?;

                // Use actual parameter names from event definition
                for (param_info, arg) in event_info.params.iter().zip(emit.args.iter()) {
                    let arg_code = self.generate_expression(arg)?;
                    code.push_str(&format!("{}    {}: {},\n", indent_str, param_info.0, arg_code));
                }
                code.push_str(&format!("{}}});\n", indent_str));
            }
            Stmt::If(if_stmt) => {
                let cond = self.generate_expression(&if_stmt.condition)?;
                code.push_str(&format!("{}if {} {{\n", indent_str, cond));

                for s in &if_stmt.then_branch {
                    code.push_str(&self.generate_statement(s, indent + 4)?);
                }

                // Elif branches
                for (elif_cond, elif_body) in &if_stmt.elif_branches {
                    let elif_cond_code = self.generate_expression(elif_cond)?;
                    code.push_str(&format!("{}}} else if {} {{\n", indent_str, elif_cond_code));
                    for s in elif_body {
                        code.push_str(&self.generate_statement(s, indent + 4)?);
                    }
                }

                // Else branch
                if let Some(else_body) = &if_stmt.else_branch {
                    code.push_str(&format!("{}}} else {{\n", indent_str));
                    for s in else_body {
                        code.push_str(&self.generate_statement(s, indent + 4)?);
                    }
                }

                code.push_str(&format!("{}}}\n", indent_str));
            }
            Stmt::While(while_stmt) => {
                let cond = self.generate_expression(&while_stmt.condition)?;
                code.push_str(&format!("{}while {} {{\n", indent_str, cond));

                for s in &while_stmt.body {
                    code.push_str(&self.generate_statement(s, indent + 4)?);
                }

                code.push_str(&format!("{}}}\n", indent_str));
            }
            Stmt::Pass => {
                code.push_str(&format!("{}// pass\n", indent_str));
            }
            _ => {
                return Err(CodegenError::UnsupportedFeature(format!("Statement {:?}", stmt)));
            }
        }

        Ok(code)
    }

    /// Generate expression code
    fn generate_expression(&self, expr: &Expr) -> CodegenResult<String> {
        match expr {
            Expr::IntLiteral(n) => Ok(n.clone()),
            Expr::BoolLiteral(b) => Ok(b.to_string()),
            Expr::StringLiteral(s) => Ok(format!("\"{}\"", s)),
            Expr::Ident(name) => {
                // Check if it's a state variable
                if self.account_fields.contains_key(name) {
                    Ok(format!("contract.{}", name))
                } else {
                    Ok(name.clone())
                }
            }
            Expr::BinOp(left, op, right) => {
                let left_code = self.generate_expression(left)?;
                let right_code = self.generate_expression(right)?;

                let op_str = match op {
                    BinOp::Add => "+",
                    BinOp::Sub => "-",
                    BinOp::Mul => "*",
                    BinOp::Div => "/",
                    BinOp::Mod => "%",
                    BinOp::Eq => "==",
                    BinOp::NotEq => "!=",
                    BinOp::Lt => "<",
                    BinOp::Gt => ">",
                    BinOp::LtEq => "<=",
                    BinOp::GtEq => ">=",
                    BinOp::And => "&&",
                    BinOp::Or => "||",
                    _ => return Err(CodegenError::UnsupportedFeature(format!("BinOp {:?}", op))),
                };

                Ok(format!("({} {} {})", left_code, op_str, right_code))
            }
            Expr::Call(func, args) => {
                if let Expr::Ident(func_name) = &**func {
                    let arg_codes: Vec<_> = args.iter()
                        .map(|a| self.generate_expression(a))
                        .collect::<Result<_, _>>()?;

                    match func_name.as_str() {
                        "address" => {
                            if args.len() == 1 {
                                // Special case: address(0) should be Pubkey::default()
                                if let Expr::IntLiteral(n) = &args[0] {
                                    if n == "0" {
                                        return Ok("Pubkey::default()".to_string());
                                    }
                                }
                                Ok(arg_codes[0].clone())
                            } else {
                                Err(CodegenError::UnsupportedFeature("address() requires 1 argument".to_string()))
                            }
                        }
                        "safe_add" => Ok(format!("{}.checked_add({}).expect(\"arithmetic overflow\")", arg_codes[0], arg_codes[1])),
                        "safe_sub" => Ok(format!("{}.checked_sub({}).expect(\"arithmetic underflow\")", arg_codes[0], arg_codes[1])),
                        _ => Ok(format!("{}({})", func_name, arg_codes.join(", "))),
                    }
                } else {
                    Err(CodegenError::UnsupportedFeature("Complex function calls".to_string()))
                }
            }
            Expr::Attribute(base, attr) => {
                if let Expr::Ident(base_name) = &**base {
                    if base_name == "msg" && attr == "sender" {
                        return Ok("signer".to_string());
                    } else if base_name == "self" {
                        return Ok(format!("contract.{}", attr));
                    }
                }
                Err(CodegenError::UnsupportedFeature(format!("Attribute {}.{}", "base", attr)))
            }
            Expr::Index(target, index) => {
                // Handle nested indexing: self.allowances[key1][key2]
                if let Expr::Index(nested_target, nested_index) = &**target {
                    // Nested mapping access
                    if let Expr::Attribute(base, attr) = &**nested_target {
                        if let Expr::Ident(base_name) = &**base {
                            if base_name == "self" {
                                let first_key = self.generate_expression(nested_index)?;
                                let second_key = self.generate_expression(index)?;
                                return Ok(format!(
                                    "contract.{}.get(&{}).and_then(|inner| inner.get(&{})).cloned().unwrap_or_default()",
                                    attr, first_key, second_key
                                ));
                            }
                        }
                    }
                } else if let Expr::Attribute(base, attr) = &**target {
                    // Simple mapping access
                    if let Expr::Ident(base_name) = &**base {
                        if base_name == "self" {
                            let key_code = self.generate_expression(index)?;
                            return Ok(format!("contract.{}.get(&{}).cloned().unwrap_or_default()", attr, key_code));
                        }
                    }
                }
                Err(CodegenError::UnsupportedFeature(format!("Index {:?}", expr)))
            }
            _ => Err(CodegenError::UnsupportedFeature(format!("Expression {:?}", expr))),
        }
    }

    /// Generate account structures
    fn generate_accounts(&self) -> CodegenResult<String> {
        let mut code = String::new();

        // Initialize context
        code.push_str("#[derive(Accounts)]\n");
        code.push_str("pub struct Initialize<'info> {\n");
        code.push_str("    #[account(\n");
        code.push_str("        init,\n");
        code.push_str("        payer = signer,\n");
        code.push_str("        space = 8 + 1024 // Discriminator + data\n");
        code.push_str("    )]\n");
        code.push_str("    pub contract: Account<'info, ContractState>,\n");
        code.push_str("    #[account(mut)]\n");
        code.push_str("    pub signer: Signer<'info>,\n");
        code.push_str("    pub system_program: Program<'info, System>,\n");
        code.push_str("}\n\n");

        // Generic instruction context (for other functions)
        code.push_str("#[derive(Accounts)]\n");
        code.push_str("pub struct ExecuteInstruction<'info> {\n");
        code.push_str("    #[account(mut)]\n");
        code.push_str("    pub contract: Account<'info, ContractState>,\n");
        code.push_str("    pub signer: Signer<'info>,\n");
        code.push_str("}\n\n");

        // Contract state account
        code.push_str("#[account]\n");
        code.push_str("pub struct ContractState {\n");

        for (name, ty) in &self.account_fields {
            code.push_str(&format!("    pub {}: {},\n", name, ty));
        }

        code.push_str("}\n\n");

        Ok(code)
    }

    /// Generate event structures
    fn generate_events(&self) -> CodegenResult<String> {
        let mut code = String::new();

        for event in &self.events {
            code.push_str("#[event]\n");
            code.push_str(&format!("pub struct {}Event {{\n", event.name));

            for (name, ty) in &event.params {
                code.push_str(&format!("    pub {}: {},\n", name, ty));
            }

            code.push_str("}\n\n");
        }

        Ok(code)
    }

    /// Convert snake_case to PascalCase
    fn to_pascal_case(&self, s: &str) -> String {
        s.split('_')
            .map(|word| {
                let mut chars = word.chars();
                match chars.next() {
                    None => String::new(),
                    Some(first) => {
                        first.to_uppercase().collect::<String>() + chars.as_str()
                    }
                }
            })
            .collect()
    }
}

impl Default for SolanaCodegen {
    fn default() -> Self {
        Self::new()
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_codegen_creation() {
        let _codegen = SolanaCodegen::new();
    }

    #[test]
    fn test_type_mapping() {
        let codegen = SolanaCodegen::new();
        assert_eq!(codegen.map_type(&Type::Simple("uint256".to_string())), "u128");
        assert_eq!(codegen.map_type(&Type::Simple("address".to_string())), "Pubkey");
        assert_eq!(codegen.map_type(&Type::Simple("bool".to_string())), "bool");
    }
}
